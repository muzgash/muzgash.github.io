<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport"    content="width=device-width, initial-scale=1.0">
	<meta name="description" content="curriculum vitae of Gerado Gutierrez. Projects including iot, data science, finance, programming, artificial intelligence and lots of coffee">
	<meta name="author"      content="Gerardo Gutierrez">
	<meta name="robots" content="index, follow">

	<title>Courses</title>

	<link rel="shortcut icon" href="http://gerardogutierrez.co/en/images/favicon.png">

	
	<link href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.no-icons.min.css" rel="stylesheet">
	
	<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
	
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Alice|Open+Sans:400,300,700">
	
	<link rel="stylesheet" href="http://gerardogutierrez.co/en/css/styles.css">

	

    
        <script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=&product=inline-share-buttons"></script>
    

</head>
<body class="home">

<header id="header">
	<div id="head" class="parallax" parallax-speed="2">
		<h1 id="logo" class="text-center">
			<img class="img-circle" src="http://gerardogutierrez.co/en/images/guy.jpg" alt="">
			<span class="title">Gerardo Gutiérrez</span>
			<span class="tagline"><br>
				<a href="">ggutierg@gmail.com</a>
            </span>
		</h1>
	</div>

    <nav class="navbar navbar-default navbar-sticky">
    <div class="container-fluid">

        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="true">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>

        <div class="navbar-collapse collapse" id="bs-example-navbar-collapse-1">

            <ul class="nav navbar-nav">
                
                
                <li class="active"><a href="/en">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Data Science & AI <b class="caret"></b></a>
                    <ul class="dropdown-menu">
						
						<li>
							<a href="/en/data/cn">Complex Networks</a>
						</li>
						
						<li>
							<a href="/en/data/finance">Finance</a>
						</li>
						
						<li>
							<a href="/en/data/geophysics">Geophysics</a>
						</li>
						
						<li>
							<a href="/en/data/politics">Politics</a>
						</li>
						
						<li>
							<a href="/en/data/sn">Social Networks</a>
						</li>
						
                        
                    </ul>
                </li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">IoT <b class="caret"></b></a>
                    <ul class="dropdown-menu">
						
						<li>
							<a href="/en/iot/marbles">Biorreactor</a>
						</li>
						
						<li>
							<a href="/en/iot/security">Security System</a>
						</li>
						
                        
                    </ul>
                </li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Education <b class="caret"></b></a>
                    <ul class="dropdown-menu">
						
						<li>
							<a href="/en/doc/courses">Courses</a>
						</li>
						
						<li>
							<a href="/en/doc/tutorials">Tutorials</a>
						</li>
						
                        
                    </ul>
                </li>
                <li class="active"><a href="/en/coffee">Coffee</a></li>
                <li class="active"><a href="/en/about">About</a></li>
                
                
            </ul>

        </div>
    </div>
</nav>


</header>


<main id="main">

	<div class="container">
		<div class="row topspace">
			<div class="col-sm-8 col-sm-offset-2">

                
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
							<span class="posted-on"><time class="entry-date published" date="2014-12-05 12:00:00 &#43;0000 &#43;0000">December 5, 2014</time></span>
						</div>
						<h1 class="entry-title"><a href="http://gerardogutierrez.co/en/courses/hpc/" rel="bookmark">Computación de alto desempeño en C</a></h1>
					</header>
					<div class="entry-content">
						

<h1 id="under-translation">UNDER TRANSLATION</h1>

<h2 id="syllabus">Syllabus</h2>

<ul>
<li><a href="#omp">OpenMP</a></li>
<li><a href="#ompi">Process communication with MPI</a></li>
<li><a href="#oacc">Introduction to OpenACC</a></li>
</ul>

<h3 id="a-id-omp-openmp-a"><a id="omp">OpenMP</a></h3>

<p>En la sección anterior vimos cuan complejo puede ser el trabajo con bifuraciones o con hilos, aún más si queremos compartir información entre procesos. OpenMP fue creado para facilitar este trabajo, consiste en un conjunto de instrucciones para loslenguajes C/C++ y fortran de facil despliegue para resolver problemas complejos. OpenMP permite al usuario crear hilos; definir como se van a repartir las tareas y las variables; y sincronizar los hilos.
Veamos la sintaxis para paralelizar un ciclo simple:</p>

<pre><code class="language-cpp">int main()
{
    int i;
    #pragma omp parallel for
        for(i=0;i&lt;8;i++) sleep(2);
}
</code></pre>

<p>Compilamos normalmente con gcc sleep.c</p>

<p><strong>Preguntas</strong></p>

<ul>
<li>¿Cuánto tiempo demora en ejecutar?</li>
<li>¿Cuánto tiempo demora si compilamos esta vez con la opción -fopenmp?</li>
</ul>

<p>Observemos la salida de los comandos</p>

<pre><code>gcc -E sleep.c
gcc -E sleep.c -fopenmp
</code></pre>

<p>La directiva <code>#pragma</code> junto con <code>omp for</code> nos permite decirle al compilador que el siguiente ciclo va a ser ejecutado en hilos.<br />
Openmp también tiene algunas funciones, para poder invocarlas debemos incluir la librería omp.h. En este caso usamos la función omp_get_thread_num() para saber en que hilo estamos.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;omp.h&gt;

int main(int argc, char **argv) {
    int i,n=8;
    #pragma omp parallel for
        for(i=0;i&lt;n;i++)
            printf(&quot;Hilo %d ejecutando  la iteracion %d\n&quot;,omp_get_thread_num(),i);
        return 0;
}
</code></pre>

<p>Ahora agregemos al código anterior una línea que nos permitirá definir el número de hilos de la sección a paralelizar:</p>

<pre><code>#include&lt;omp.h&gt;
#include&lt;stdio.h&gt;
int main()
{
    int i,n=8;
    omp_set_num_threads(4);
    #pragma omp parallel for
        for(i=0;i&lt;n;i++)
            printf(&quot;Hilo %d ejecutando  la iteracion %d\n&quot;,omp_get_thread_num(),i);
        return 0;
}
</code></pre>

<p>También podemos paralelizar secciones de código</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;omp.h&gt;

int main()
{
    omp_set_num_threads(4);
        #pragma omp parallel
        {
            printf(&quot;Este es el thread numero %d\n&quot;,omp_get_thread_num());
        }
}
</code></pre>

<p>Juguemos ahora con la visibilidad de las variables imprimiendo su dirección dentro de un ciclo paralelizado:</p>

<pre><code>#include&lt;stdio.h&gt;

int main() {
    int i,n=3,a=1,b=1;
    #pragma omp parallel for
        for(i=0;i&lt;n;i++) {
            printf(&quot;Las direcciones: &amp;a = %x y &amp;b = %x\n&quot;,&amp;a,&amp;b);
        }
        return 0;
}
</code></pre>

<p><strong>Preguntas</strong></p>

<ul>
<li>Pruebe cambiando la directiva pragma por: #pragma omp parallel for private(b)</li>
<li>Pruebe cambiando la directiva pragma por: #pragma omp parallel for default(none)</li>
<li>¿Qué pasa con el siguiente código?</li>
</ul>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;omp.h&gt;

int main(int argc, char **argv) {
    int i,n=10,a=1,b=1,c;
    #pragma omp parallel for
    for(i=0;i&lt;n;i++) {
            c=a+b;
            printf(&quot;En la iteración %d a = %d, b = %d y c = %d\n&quot;,i,a,b,c);
            a=b;
            b=c;
    }
    return 0;
}
</code></pre>

<p>En el código a continuación no preserva los valores de la variable a luego de la sección paralelizada:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;omp.h&gt;

int main()
{
    int i,n=4,a=0;
    #pragma omp parallel for private(i,a)
        for(i=0;i&lt;n;i++){
            a=a+i;
                printf(&quot;En el hilo %d a = %d\n&quot;,omp_get_thread_num(),i,a);
        }
        printf(&quot;Luego del ciclo paralelo a = %d\n&quot;,a);
}
</code></pre>

<p>Para avitar esto cambiamos la directiva por #pragma omp parallel for private(i) lastprivate(a).
Si queremos realizar varias tareas al mismo tiempo que no están ligadas por un ciclo for usamos la directiva nowait:</p>

<pre><code>#include&lt;omp.h&gt;
#include&lt;stdio.h&gt;
int main()
{
    int i,n=8;
    omp_set_num_threads(4);
    #pragma omp parallel
    {
        #pragma omp for nowait
        for(i=0;i&lt;8;i++) {
            printf(&quot;Esperando %d segundos\n&quot;,i);
            sleep(i);
        }
        printf(&quot;Hilo %d ejecutando  la iteracion %d\n&quot;,omp_get_thread_num(),i);
    }
    return 0;
}
</code></pre>

<p>Las variables privadas no quedan con un valor al entrar en una sección o en un for paralelo, unicamente se crea un espacio en memoria privado al que solo puede acceder cada hilo. Veamos un ejemplo:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;omp.h&gt;

int main()
{
    int a=0,b=16;
        omp_set_num_threads(4);
        #pragma omp parallel private(b) shared(a)
        {
            a+=b;
                printf(&quot;en el hilo %d el valor de a es %d\n&quot;,omp_get_thread_num(),a);
        }
        printf(&quot;Fuera de los hilos el valor de a es %d\n&quot;,a);
    return 0;
}
</code></pre>

<p>Si cmbiamos la diretiva private(b) por firstprivate(b) vemos que el valor de b es copiado en cada una de ls posiciones de memoria de la variable b privada a cada hilo.</p>

<p><strong>Preguntas</strong></p>

<ul>
<li>¿Qué pasa si en este caso hago provada también a? ¿Cuál es debería ser el valor que acumula?</li>
<li>¿Por qué al correr varias veces el ejecutable el valor de a es diferente?</li>
</ul>

<p>Existe una forma de hacer que los hilos escojan pedazos de tamaño determinad del ciclo en paralelo, a esto se le llama agendamiento o <em>scheduling</em>. Openmp usa estático por defecto, también existe el dinámico, guiado y runtime. Veamos la diferencia entre las tres primeras con el siguiente código</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;omp.h&gt;
int main(int argc, char **argv) {
    int i,n=48;
    #pragma omp parallel for schedule(static,3)
    for(i=0;i&lt;n;i++)
        printf(&quot;Hilo %d ejecutando  la iteracion %d\n&quot;,omp_get_thread_num(),i);
    return 0;
}
</code></pre>

<p>Cambiemos allí static por dynamic y luego por guided y observemos la diferencia entre las salidas.</p>

<p>Cuando estamos modificando una variable compartida hilos podría ir a actualizarla al mismo tiempo, esto producirá problemas pues no tenemos certeza de cual valor va a ser con el que quede al final dicha variable. En este ejemplo tratamos de sumar los datos de un arreglo</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;omp.h&gt;
int main()
{
    int i,n=10,sum=0,a[10]={1,2,3,4,5,6,7,8,9,10};
    int sumaParcial;
    #pragma omp parallel shared(n,a,sum) private(sumaParcial)
    {
        sumaParcial=0;
        #pragma omp for
        for(i=0;i&lt;n;i++)
           sumaParcial+=a[i];
        sum+=sumaParcial;
         printf(&quot;En el hilo %d sumaparcial=%d y sum=%d\n&quot;,omp_get_thread_num(),sumaParcial,sum);
    }
    printf(&quot;Luego de la región paralela sum=%d\n&quot;,sum);
    return 0;
}
</code></pre>

<p>Esto lo podemos solucionar de 2 maneras, una es usando la directiva critical. Esta obliga a los hilos a que no intenten actualizar la variable al mismo tiempo:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;omp.h&gt;
int main()
{
    int i,n=10,sum=0,a[10]={1,2,3,4,5,6,7,8,9,10};
    int sumaParcial;
    #pragma omp parallel shared(n,a,sum) private(sumaParcial)
    {
        sumaParcial=0;
        #pragma omp for
        for(i=0;i&lt;n;i++)
           sumaParcial+=a[i];
        #pragma omp critical
        {
            sum+=sumaParcial;
            printf(&quot;En el hilo %d sumaparcial=%d y sum=%d\n&quot;,omp_get_thread_num(),sumaParcial,sum);
        }
    }
    printf(&quot;Luego de la región paralela sum=%d\n&quot;,sum);
    return 0;
}
</code></pre>

<p>Otra forma es con la instrucción reduction la sintaxis es reduction(operador:variable). Leugo de que la sección paralela concluya, se hará la operación sobre la variable. Es equivalente al caso anterior pero es mucho más legible luego es más recomendada. Con esta instrucción podemos simplificar el código anterior</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;omp.h&gt;
int main()
{
    int i,n=10,sum=0,a[10]={1,2,3,4,5,6,7,8,9,10};
    #pragma omp parallel for reduction(+:sum)
    for(i=0;i&lt;n;i++)
        sum+=a[i];
    printf(&quot;Luego de la región paralela sum=%d\n&quot;,sum);
    return 0;
}
</code></pre>

<p><strong>Ejercicios</strong></p>

<ul>
<li>Halle en paralelo el valor aproximado de la función zeta de Riemann para n={2,3,4} hasta el término 800 de la siguiente sumatoria<br /></li>
</ul>

<div>$$\zeta(n)=\sum\limits_{k=1}^{\infty}\left(\frac{1}{k^n}\right)$$</div>

<p>Los resultados deben ser similares a
<div>$$\zeta(2)=\left(\frac{\pi^2}{6}\right)$$</div>
<div>$$\zeta(3)= 1.202056903159594295399738$$</div>
<div>$$\zeta(4)=\left(\frac{\pi^4}{90}\right)$$</div></p>

<ul>
<li>Grafique los tiempos que toma su algoritmo para un número de hilos desde la cantidad que soporta su procesador hasta 800.</li>
<li>Realice la multiplicación de una matriz por un vector en paralelo. Puede usar la siguiente función(las matrices deben estar guardadas en un arreglo unidimensional):</li>
</ul>

<pre><code>void mxv(int m, int n, float *a, float *b, float *result)
{
//Calcula la multiplicación de la matriz a por el vector b.
    int i,j;
    for(i=0;i&lt;m;i++)
    {
        result[i]=0.0;
        for(j=0;j&lt;n;j++) result[i]+=a[i*n+j]*b[j]
    }
}
</code></pre>

<ul>
<li>Encuentre el determinante de una matriz 3x3 a través de la fórmula</li>
</ul>

<div>$$Det(A)=\sum_{i,j,k}a_{0i} a_{1j} a_{2 k} \epsilon_{ijk}$$</div>

<ul>
<li>Realice la transpuesta de una matriz.</li>
<li>Realicemos la siguiente integral por el método de montecarlo en paralelo:</li>
</ul>

<div>$$\int_1^2\frac{dx}{1-sin(x)*ln(\frac{1}{x})}$$</div>

<p>Debe dar aproximadamente 0.743156. Puede ayudarse del siguiente código</p>

<pre><code>float max(float (*funcion)(float),float xmin, float xmax)
{
    float x,y,dmax=0,step=0.001;
    for(x=xmin;x&lt;=xmax; x+=step)
    {
        y=funcion(x);
        if(y&gt;dmax) dmax=y; 
    }
    return dmax;
}
float montecarlo(float (*funcion)(float),float xmin, float xmax, float paso, int N) 
{
    float ry; //Numero aleatorio en Y
    float x,y;
    float ymax;
    ymax=max(funcion,xmin,xmax);
    int cont;//iterador de los numeros aleatorios
    int suma=0;//cantidad de puntos aleatorios debajo de la curva
    srand48(time(NULL));
    for(x=xmin;x&lt;=xmax;x+=paso)
    {
        y=funcion(x);
    	for(cont=0;cont&lt;N;cont++)
	{
            ry=drand48()*ymax;
	    if( ry &lt; y )
	    {
	        suma++;
	    }
	}
    }
    return suma*paso*ymax/N;//La fracción de los números aleatorios por el área de la caja
}
</code></pre>

<ul>
<li>Usando torque o condor, envíe al cluster los códigos anteriores de manera que en cada nodo realicen su tarea con 2 hilos. Reporte la diferencia en los tiempos de ejecución con el uso de hilos y sin ellos.</li>
<li>Dado un conjunto de k + 1 puntos
<div>$$(x_0,y_0),\,\,(x_1,y_1),\,\,(x_2,y_2),\,\, \dots,\,\, (x_k,y_k),$$</div></li>
</ul>

<p>donde todos los xj se asumen distintos, el polinomio interpolador en la forma de Lagrange es la combinación lineal.</p>

<div>$$L(x)=\sum\limits_{j=0}^k y_{j}l_{j}(x)$$</div>

<p>de bases polinómicas de Lagrange</p>

<div>$$l_j(x)=\prod\limits_{i=0,i\neq j}^k \frac{(x-x_i)}{x_j-x_i}$$</div>

<p>Genere 10 puntos entre 0 y 1 del integrando anterior, con estos datos realice la intrepolación de lagrane para obtener 10 puntos adicionales.</p>

<ul>
<li>Dado un conjunto de k + 1 puntos</li>
</ul>

<div>$$\overline{f(k)}=\sum\limits_{n=0}^{n=N}e^{(2i\pi xk)}f(x)\delta x$$</div>

<ul>
<li>Encuente la media, varianza, desviación estandar y el coeficiente de correlación de Pearson de los datos que descarga <a href="http://c3.itm.edu.co/computacionDistribuida/shares.tbz2" target="_blank">aquí</a>. También incluya los valores máximo y mínimo con su fecha de ocurrencia.
Recuerde que</li>
</ul>

<div>$$\sigma^2=\frac{1}{N}\sum_{i=1}^{N}(x_i-\overline{x})^2$$</div>
<div>$$C_v=\frac{\sigma}{\overline{x}}$$</div>

<p>Escriba su reporte a un archivo diferente para cada conjunto de datos.</p>

<ul>
<li>Con los datos anteriores realice también una regresión lineal(sólo a los datos de este año) y halle su coeficiente de determinación. Tenga en cuenta que:
<div>$$a1=\frac{\sum (x_i-\overline{x})(y_i-\overline{y})}{\sum (x_i-\overline{x})^2}$$</div>
<div>$$a_0=\overline{y}-a_1\overline{x}$$</div></li>
</ul>

<p>Donde la línea de regresión tiene la forma</p>

<div>$$y=a_0+a_1 x$$</div>
<div>$$r=\frac{\sum (x_i-\overline{x})(y_i-\overline{y})}{\sum (x_i-\overline{x})^2 \sum (y_i-\overline{y})^2}$$</div>

<h3 id="a-id-ompi-mpi-a"><a id="ompi">MPI</a></h3>

<p>MPI (&ldquo;Message Passing Interface&rdquo;, Interfaz de Paso de Mensajes) es un estándar que define la sintaxis y la semántica de las funciones contenidas en una biblioteca de paso de mensajes diseñada para ser usada en programas que exploten la existencia de múltiples procesadores.</p>

<h3 id="estructuta-general-de-un-programa-mpi">Estructuta General de un programa MPI</h3>

<ul>
<li>MPI include header file #include &ldquo;mpi.h&rdquo;</li>
<li>Inicializar el ambiente  MPI</li>
<li>Código principal con los pasos de mensajes</li>
<li>Finalizar el ambiente MPI</li>
</ul>

<pre><code>MPI_Init (&amp;argc,&amp;argv) 
MPI_Comm_size (comm,&amp;size) 
MPI_Comm_rank (comm,&amp;rank) 
MPI_Abort (comm,errorcode) 
MPI_Get_processor_name (&amp;name,&amp;resultlength) 
MPI_Finalize ()
</code></pre>

<h3 id="hola-mundo">Hola Mundo</h3>

<pre><code>#include &quot;mpi.h&quot;
   #include &lt;stdio.h&gt;

   int main(argc,argv)
   int argc;
   char *argv[]; {
   int  numtasks, rank, rc; 
   char processor_name[MPI_MAX_PROCESSOR_NAME];
   int  namelen;


   rc = MPI_Init(&amp;argc,&amp;argv);
   if (rc != MPI_SUCCESS) {
     printf (&quot;Error starting MPI program. Terminating.\n&quot;);
     MPI_Abort(MPI_COMM_WORLD, rc);
     }

   MPI_Comm_size(MPI_COMM_WORLD,&amp;numtasks);
   MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);
   MPI_Get_processor_name(processor_name,&amp;namelen);
   printf (&quot;Number of tasks= %d My rank= %d My processor name=%s\n&quot;, numtasks,rank ,processor_name);

   /*******  do some work *******/

   MPI_Finalize();

   }
</code></pre>

<h3 id="compilación-de-mpi">Compilación de mpi</h3>

<p>Para compilar un código en mpi podemos usar un comando que viene con el paquete de mpi
llamado mpicc para c o mpicxx para c++ o mpif77,mpif90 para fortran.</p>

<p><code>mpicc hello.c -o hello.out</code></p>

<h3 id="ejecución-de-mpi">Ejecución de mpi</h3>

<p>Para ejecutar programas en mpi necesitamos usa un comando que se llama mpiexec o mpirun,
este se encarga de orquestar todas las comunicaciones para el paso de mensajes a través de los nodos de calculo.</p>

<p><code>mpirun -np 4 ./hello.out</code></p>

<p>para decir explicitamente en que máquinas queremos ejecutar nuetros procesos podemos crear un archivo que contenga explicitamente los nodos y su numero de cpus, para este ejemplo llamemoslo machines.txt</p>

<pre><code>wn0 slots=2
wn1 slots=2
</code></pre>

<p>con este arhcivo le podemos indicar a mpirun que me ejecute los cuatro procesos en esas dos maquinas en dos de sus cpus asi.</p>

<p><code>mpirun -np 4 -machinefile machines.txt ./hello.out</code></p>

<p>Pero para poder que los procesos de todos los usuarios no colisionen se tiene que ajustar los parametros en un script de de torque de la siguiente forma.</p>

<pre><code>#! /bin/bash
#PBS -N mpi
#PBS -o mpi.out
#PBS -e mpi.err
#PBS -l walltime=00:01:00
#PBS -l nodes=4:ppn=1
cd  $PBS_O_WORKDIR
cat $PBS_NODEFILE
mpirun -np 4 -machinefile $PBS_NODEFILE ./hello.out{CODE}
</code></pre>

<h1 id="comunicaciones-p2p">Comunicaciones p2p</h1>

<p>Es la comunicacion entre dos procesos.</p>

<p>MPI_Send(buffer,count,type,dest,tag,comm) &mdash;&gt; MPI_Recv(buffer,count,type,source,tag,comm,status)</p>

<h3 id="ejemplo">Ejemplo</h3>

<pre><code>#include &quot;mpi.h&quot;

#include &lt;stdio.h&gt;

int main(argc,argv) 
int argc;
char *argv[];  {
int numtasks, rank, dest, source, rc, count, tag=1;  
char inmsg, outmsg='x';
MPI_Status Stat;

MPI_Init(&amp;argc,&amp;argv);
MPI_Comm_size(MPI_COMM_WORLD, &amp;numtasks);
MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);

if (rank == 0) {
  dest = 1;
  source = 1;
  rc = MPI_Send(&amp;outmsg, 1, MPI_CHAR, dest, tag, MPI_COMM_WORLD);
  rc = MPI_Recv(&amp;inmsg, 1, MPI_CHAR, source, tag, MPI_COMM_WORLD, &amp;Stat);
  } 

else if (rank == 1) {
  dest = 0;
  source = 0;
  rc = MPI_Recv(&amp;inmsg, 1, MPI_CHAR, source, tag, MPI_COMM_WORLD, &amp;Stat);
  rc = MPI_Send(&amp;outmsg, 1, MPI_CHAR, dest, tag, MPI_COMM_WORLD);
  }

rc = MPI_Get_count(&amp;Stat, MPI_CHAR, &amp;count);
printf(&quot;Task %d: Received %d char(s) from task %d with tag %d \n&quot;,
       rank, count, Stat.MPI_SOURCE, Stat.MPI_TAG);



MPI_Finalize();
}
</code></pre>

<p><strong>Ejercicios</strong></p>

<ul>
<li>Hacer un algoritmo que reciba en el rango cero, nombre del host de donde se ejecutaron los demás rangos</li>
<li>Hacer un algoritmo que mande un vector a todos los rangos</li>
<li>Hacer una integral por sumas de Riemann</li>
</ul>

<p><strong>Ejercicio 1</strong></p>

<pre><code>#include &quot;mpi.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(argc,argv) 
int argc;
char *argv[];  {
int numtasks, rank, dest, source, rc, count, tag=1,namelen;  
//char *inmsg;
char processor_name[MPI_MAX_PROCESSOR_NAME];

MPI_Status Stat;
MPI_Init(&amp;argc,&amp;argv);
MPI_Comm_size(MPI_COMM_WORLD, &amp;numtasks);
MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);

if (rank == 0) {
int i;
        for(i=1;i&lt;numtasks;i++)
        {
                MPI_Recv(&amp;namelen, 1, MPI_INT, i, tag, MPI_COMM_WORLD, &amp;Stat);
                char inmsg[namelen];
                MPI_Recv(inmsg, namelen, MPI_CHAR, i, tag, MPI_COMM_WORLD, &amp;Stat);
                printf(&quot;recibido host=%s desde rango=%d\n&quot;,inmsg,i);
        }
  } 

else {

  MPI_Get_processor_name(processor_name,&amp;namelen);
  MPI_Send(&amp;namelen,1, MPI_INT, 0, tag, MPI_COMM_WORLD);
  MPI_Send(processor_name, namelen, MPI_CHAR, 0, tag, MPI_COMM_WORLD);
  printf(&quot;enviando host=%s desde rango=%d\n&quot;,processor_name,rank);
  }
MPI_Finalize();
}
</code></pre>

<p><strong>Ejercicio 2 (Broadcast)</strong></p>

<pre><code>#include &quot;mpi.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(argc,argv) 
int argc;
char *argv[];  {
int numtasks, rank, dest, source, rc, count, tag=1,namelen;  

MPI_Status Stat;
MPI_Init(&amp;argc,&amp;argv);
MPI_Comm_size(MPI_COMM_WORLD, &amp;numtasks);
MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
if (rank == 0) {
	int i;
	double data[2]={0,2*3.1416};
	printf(&quot;enviando dato[0]=%lf dato[1]=%lf desde rango=%d\n&quot;,data[0],data[1],i);
        for(i=1;i&lt;numtasks;i++)
        {
                MPI_Send(data,2, MPI_DOUBLE, i, tag, MPI_COMM_WORLD);
        }
  }else {
      double data[2];
      MPI_Recv(data, 2, MPI_DOUBLE, 0, tag, MPI_COMM_WORLD, &amp;Stat);
      printf(&quot;recibido dato[0]=%lf dato[1]=%lf desde rango=%d\n&quot;,data[0],data[1],rank);
  }
MPI_Finalize();
}
</code></pre>

<h2 id="comunicación-colectiva">Comunicación colectiva</h2>

<h3 id="broadcast">Broadcast</h3>

<p><code>MPI_Bcast(void* data, int count, MPI_Datatype datatype, int root, MPI_Comm communicator)</code></p>

<p><strong>Ejemplo</strong></p>

<pre><code>#include &quot;mpi.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(argc,argv) 
int argc;
char *argv[];  {
int numtasks, rank, dest, source=0, rc, count, tag=1;  

MPI_Status Stat;
MPI_Init(&amp;argc,&amp;argv);
MPI_Comm_size(MPI_COMM_WORLD, &amp;numtasks);
MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
double data[2];
if (rank == 0) {
	data[0]=0;
	data[1]=2*3.1416;
}

MPI_Bcast(data, 2, MPI_DOUBLE, source, MPI_COMM_WORLD);
printf(&quot;recibido dato[0]=%lf dato[1]=%lf en rango=%d\n&quot;,data[0],data[1],rank);

MPI_Finalize();
}
</code></pre>

<h3 id="reduce">Reduce</h3>

<ul>
<li><strong>MPI_MAX</strong> – Returns the maximum element.</li>
<li><strong>MPI_MIN</strong> – Returns the minimum element.</li>
<li><strong>MPI_SUM</strong> – Sums the elements.</li>
<li><strong>MPI_PROD</strong> – Multiplies all elements.</li>
<li><strong>MPI_LAND</strong> – Performs a logical “and” across the elements.</li>
<li><strong>MPI_LOR</strong> – Performs a logical “or” across the elements.</li>
<li><strong>MPI_BAND</strong> – Performs a bitwise “and” across the bits of the elements.</li>
<li><strong>MPI_BOR</strong> – Performs a bitwise “or” across the bits of the elements.</li>
<li><strong>MPI_MAXLOC</strong> – Returns the maximum value and the rank of the process that owns it.</li>
<li><strong>MPI_MINLOC</strong> – Returns the minimum value and the rank of the process that owns it.</li>
</ul>

<p><code>MPI_Reduce(void* send_data, void* recv_data, int count,MPI_Datatype datatype, MPI_Op op, int root, MPI_Comm communicator)</code></p>

<p><strong>Ejemplo</strong></p>

<pre><code>#include &quot;mpi.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(argc,argv) 
int argc;
char *argv[];  {
int numtasks, rank, dest=0, rc, count, tag=1;  

MPI_Status Stat;
MPI_Init(&amp;argc,&amp;argv);
MPI_Comm_size(MPI_COMM_WORLD, &amp;numtasks);
MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
int sum=0;

MPI_Reduce(&amp;rank, &amp;sum, 1,MPI_INT, MPI_SUM, dest,MPI_COMM_WORLD);

if(rank==0)
{
printf(&quot;la suma de todos los rangos es =%d\n&quot;,sum);
}
MPI_Finalize();
}
</code></pre>

<h3 id="scatter">Scatter</h3>

<pre><code>#include &lt;stdio.h&gt;
#include &quot;mpi.h&quot;

int main( int argc, char **argv )
{
    int isend[3], irecv;
    int rank, size, i;

    MPI_Init( &amp;argc, &amp;argv );
    MPI_Comm_rank( MPI_COMM_WORLD, &amp;rank );
    MPI_Comm_size( MPI_COMM_WORLD, &amp;size );

    if(rank == 0){
      for(i=0;i&lt;size;i++) isend[i] = i+1;
    }

    MPI_Scatter(&amp;isend, 1, MPI_INT, &amp;irecv, 1, MPI_INT, 0, MPI_COMM_WORLD);

    printf(&quot;rank = %d: irecv = %d&quot;, rank,irecv);

    MPI_Finalize();
    return 0;
}
</code></pre>

<h3 id="gather">Gather</h3>

<pre><code>#include &lt;stdio.h&gt;
#include &quot;mpi.h&quot;

int main( int argc, char **argv )
{
    int isend, irecv[3];
    int rank, size;

    MPI_Init( &amp;argc, &amp;argv );
    MPI_Comm_rank( MPI_COMM_WORLD, &amp;rank );
    MPI_Comm_size( MPI_COMM_WORLD, &amp;size );

    isend = rank + 1;

    MPI_Gather(&amp;isend, 1, MPI_INT, &amp;irecv, 1, MPI_INT, 0, MPI_COMM_WORLD);

    if(rank == 0)
    printf(&quot;irecv = %d %d %d&quot;, irecv[0], irecv[1], irecv[2]);

    MPI_Finalize();
    return 0;
}
</code></pre>

<p><strong>Ejercicios</strong></p>

<ul>
<li>Hacer un programa que reparta una matriz con scatter</li>
<li>Hacer un programa que reciba una matriz con gather</li>
<li>Paralelizar la serie de Fourier</li>
<li>Paralelizar la interpolación de Lagrange.</li>
</ul>

<h3 id="barrier-y-wtime">Barrier y Wtime</h3>

<p>Tamibién tenemos un mecanismo para esperar que los procesos terminen para realizar una tarea posterior, a esto se le llama una barrera. Miremos el siguiente código que espera a quelos procesos terminen de hacer un simple sleep para imprimir un mensaje:</p>

<pre><code>#include&lt;mpi.h&gt;
#include&lt;stdio.h&gt;

int main(int argc, char*argv[])
{

        //MPI variables
        int rank, size;

        //MPI initialization
        MPI_Init(&amp;argc,&amp;argv);
        MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);
        MPI_Comm_size(MPI_COMM_WORLD,&amp;size);

        sleep(rank);
    printf(&quot;We are BEFORE the barrier in rank %d\n&quot;,rank);

        MPI_Barrier(MPI_COMM_WORLD);

    printf(&quot;We are now AFTER the barrier in rank %d\n&quot;,rank);
    
        MPI_Finalize();

        return 0;
}
</code></pre>

<ul>
<li>¿Qué pasa cuando le quitamos la instrucción &ldquo;MPI_Barrier&rdquo;?</li>
</ul>

<p>La instrucción MPI_Wtime() nos permite guardar en una variable de tipo double el tiempo actual, úsela en conjunto con una barrera para obtener el tiempo total de ejcución del algoritmo de multiplicación de matrices.</p>

<p><strong>Ejercicio</strong></p>

<p>El siguiente código realiza una multiplicación de matrices haciendo un scatter de las filas de A y un broadcast de las matriz B completa. Córralo con un script en torque o condor.</p>

<pre><code>int main(int argc, char *argv[])
{
    //matrix definition
    int m=4;
    int matA_send[16]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};                                                                                                                     
        int matB_send[16]={0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0};                                                                                                                        
        int matC[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};                                                                                                                             
        int chunk_send[4];                                                                                                                                                          
        int chunk_recv[4]={0,0,0,0};                                                                                                                                                
        int i,j;//iterators                                                                                                                                                         
                                                                                                                                                                                    
        //MPI variables                                                                                                                                                             
        int rank, size;                                                                                                                                                             
                                                                                                                                                                                    
        //MPI initialization                                                                                                                                                        
        MPI_Init(&amp;argc,&amp;argv);                                                                                                                                                      
        MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);                                                                                                                                        
        MPI_Comm_size(MPI_COMM_WORLD,&amp;size);                                                                                                                                        
                                                                                                                                                                                    
        MPI_Scatter(&amp;matA_send,m,MPI_INT,&amp;chunk_send,m,MPI_INT,0,MPI_COMM_WORLD);                                                                                                   
                                                                                                                                                                                    
                                                                                                                                                                                    
        MPI_Bcast(&amp;matB_send,m*m,MPI_INT,0,MPI_COMM_WORLD);                                                                                                                         
                                                                                                                                                                                    
        printf(&quot;Multiplying on rank %d\n&quot;,rank);                                                                                                                                    
        for(i=0;i&lt;m;i++) {                                                                                                                                                          
                for(j=0;j&lt;m;j++) chunk_recv[i]+=chunk_send[j]*matB_send[j*m+i];                                                                                                     
        }                                                                                                                                                                           

        MPI_Gather(&amp;chunk_recv,m,MPI_INT,&amp;matC,m,MPI_INT,0,MPI_COMM_WORLD);
        MPI_Barrier(MPI_COMM_WORLD);

    if(rank==0) {
            printf(&quot;Matrix resultado...\n&quot;);
                for(i=0;i&lt;m;i++) {
                        for(j=0;j&lt;m;j++) printf(&quot;%d &quot;,matC[i*m+j]);
                        printf(&quot;\n&quot;);
                }
        }

    
        MPI_Finalize();

        return 0;
}
</code></pre>

<p>Modifíquelo para que dentro de cada hilo se realize la multipliucación de cada columna de B por la correspondiente fila de A usando openmp.</p>

<h3 id="a-id-fileio-lectura-de-archivos-a"><a id="fileio">Lectura de archivos</a></h3>

<p>El siguiente código lee un dato espefífico de un archivo sin tener que recorrerlo completamente.
Usamos la función fseek que ubica el índice que recorre el archivo en una posición determinada. Esta posición depende del numero de bytes(caracteres) que se encuentran en cada fila del archivo.
Esto implica que el archivo a leer debe tener el mismo núnero de caracteres en cada línea.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;

int main(int argc, char *argv[])
{
    if(argc!=4) { //Manejo de error
        fprintf(stderr,&quot;Uso: ./a.out [archivo] [total de lineas] [linea a extraer]\n&quot;);
        return 1;
    }
    FILE *in;
    float num;//Numero guardado en la fila deseada en el archivo
    long int total_lines,line; //total de lineas y la linea a buscar
    char *filename;
    filename=argv[1];
    total_lines=atoi(argv[2]);
    line=atoi(argv[3]);
    if(line&gt;total_lines) { //No se puede buscar una línea fuera del total del archivo
        fprintf(stderr,&quot;linea %d es mayor que el total de líneas: %d\n&quot;,line,total_lines);
        return 1;
    }
    
    clock_t tiempo;

    tiempo=clock();//Empezamos a contar el tiempo que tarda

    in=fopen(filename,&quot;r&quot;);

    //Leyendo el primer dato
    fscanf(in,&quot;%e&quot;,&amp;num);
    printf(&quot;Encontró el número %e en la primera línea\n&quot;,num);

    //Leyendo el dato deseado
    fseek(in,(total_lines-1)*13,SEEK_SET);
    fscanf(in,&quot;%e&quot;,&amp;num);
    printf(&quot;Encontró el número %e en la última línea\n&quot;,num);

    //Leyendo el último
    fseek(in,(line-1)*13,SEEK_SET);
    fscanf(in,&quot;%e&quot;,&amp;num);
    printf(&quot;Encontró el número %e en la línea %d\n&quot;,num,line);

    tiempo=clock()-tiempo;
    printf(&quot;La lectura de estos 3 datos tomó %f segundos\n&quot;,((float)tiempo)/CLOCKS_PER_SEC);
    

    return 0;
}
</code></pre>

<h3 id="a-id-oacc-openacc-a"><a id="oacc">OpenACC</a></h3>

<p>OpenACC es un estandar de programación en tarjetas aceleradoras de video, creado en conjunto por Nvidia, CRAY, PGI y CAPS.
Su implementación se basa en la de OpenMP en la cual se usan directivas de compilación para que éste haga el trabajo de organizar el binario de tal manera que se ejecuten fragmentos de código determinados en la GPU.</p>

<p>En este momento su desarrollo aún es muy joven y los compiladores que lo soportan son propietarios y cobran por su descarga, gcc está trabajando para introducir openacc en su compilador.
En este momneto usaremos una versión de evaluación del compilador  de PGI que se encuentra ya instalada en nuestro servidor.
Para usarlo debemos incluir las siguientes líneas en el archivo de configuración del home .bashrc</p>

<pre><code>export PGI=/opt/pgi;
export PATH=/opt/pgi/linux86-64/14.10/bin:$PATH;
export MANPATH=$MANPATH:/opt/pgi/linux86-64/14.10/man;
export LM_LICENSE_FILE=$LM_LICENSE_FILE:/opt/pgi/license.dat;
</code></pre>

<p>En el siguiente ejemplo realizamos la operación Y=a*X+Y donde X e Y son arreglos:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

void saxpy(int n, float a, float *x, float *y)
{
    int i;
        for(i=0; i&lt;n; i++)
            y[i]=a*x[i]+y[i];
}

int main(int argc, char *argv[])
{
    int N=5;
        float A=2;
        float X[5]={1,2,3,4,5};
        float Y[5]={10,20,30,40,50};

        saxpy(N,A,X,Y);

        return 0;
}
</code></pre>

<ul>
<li>¿Cómo paralelizamos este código con openmp?
Simplemente agregando la línea</li>
</ul>

<pre><code>#pragma omp parallel for
</code></pre>

<p>Encima del for que se encuentra en nuestra función saxpy.</p>

<ul>
<li>¿Cómo lo paralelizamos con openacc?</li>
</ul>

<p>Simplemente agregando la línea</p>

<pre><code>#pragma acc parallel loop
</code></pre>

<p>Encima del for que se encuentra en nuestra función saxpy.</p>

<p>Para compilarlo en la línea de comando escribimos</p>

<pre><code>pgcc -acc saxpy.c -Minfo=accel
</code></pre>

<p>La opción nos va a dar Más INFOrmación sobre el proceso de compilación, vemos la salida</p>

<pre><code>saxpy:
      8, Accelerator kernel generated
          9, #pragma acc loop gang, vector(256) /* blockIdx.x threadIdx.x */
      8, Generating present_or_copyin(x[:n])
         Generating present_or_copy(y[:n])
         Generating Tesla code
</code></pre>

<p>Donde observamos que el compilador copia el arreglo x y el arreglo y de la memoria de la CPU a la de la GPU.</p>

<p>Para ejecutarlo
<code>let PGI_ACC_NOTIFY=1;./a.out</code></p>

<p>Esta variable de entorno de PGI nos permite obtener algo más de información en tiempo de ejecución, aquí podemos corroborar que nuestro código ejecutó en la GPU.</p>

<p><strong>Ejercicios</strong></p>

<ul>
<li>Realice una suma de 2 vectores</li>
<li>Haga evolución el mapa logístico</li>
</ul>

<div>$$X_{n+1}=RX_n(1-X_n)$$</div>

<p>100 pasos, donde R={1,2.5,2.6,3,3.2,3.5,3.9,4} y las condiciones iniciales tómelas cerca del punto 1-1/R.</p>

<p>Ahora vamos a resolver la ecución de laplace a través del método de jacobi, se trata de llegar al equilibrio tomando el nuevo valor como un promedio de los valores vecinos en un sistema 2D discretizado. Veamos el código de ejemplo(descargue la <a href="http://c3.itm.edu.co/computacionDistribuida/mat.txt" target="_blank">matriz</a> y ejecute de la forma ./a.out mat.txt resultado.txt):</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

int main(int argc, char *argv[])
{
    FILE *input,*eq;
        input=fopen(argv[1],&quot;r&quot;);
        eq=fopen(argv[2],&quot;w&quot;);
    int i,j,t=0,itermax=500; //Iteradores
        int n=1000,m=1000; //Dimensiones
        float A1[n][m];
        float A2[n][m];
        float tmp;
        //Llenando la matriz inicial
        for(i=0;i&lt;n;i++) {
                for(j=0;j&lt;m;j++) {
                    fscanf(input,&quot;%e&quot;,&amp;A1[i][j]);
                }
        }

        for(t=0;t&lt;itermax;t++) {
                //Iteracion sobre la matriz
                for(i=1;i&lt;n-1;i++) {
                        for(j=1;j&lt;m-1;j++) {
                                A2[i][j]=0.25*(A1[i][j+1]+A1[i][j-1]+A1[i+1][j]+A1[i-1][j]);
                        }
                }


                //Intercambio de las matrices para la evolución
                for(i=1;i&lt;n-1;i++) {
                        for(j=1;j&lt;m-1;j++) {
                                A1[i][j]=A2[i][j];
                        }
                }
        }

        for(i=0;i&lt;n;i++) {
                for(j=0;j&lt;m;j++) {
                    fprintf(eq,&quot;%d %d %e \n&quot;,i,j,A1[i][j]);
                }
        }
}
</code></pre>

<p><strong>Preguntas</strong></p>

<ul>
<li>¿Cuánto tarda el sistema con el código serial?</li>
<li>¿Cuánto tarda con openacc?</li>
</ul>

<p>Ejecute el código exportando la variable PGI_ACC_TIME=1, es decir:</p>

<p><code>export PGI_ACC_TIME=1;./a.out mat.txt result.txt</code></p>

<p>Debe uobtener una salida similar a esta:</p>

<pre><code>Accelerator Kernel Timing data
/home/gerardo.gutierrez/oacc/jacobi.c
  main  NVIDIA  devicenum=0
    time(us): 17,512
    23: data region reached 500 times
        23: data copyin transfers: 500
             device time(us): total=3,341 max=38 min=2 avg=6
        32: data copyout transfers: 500
             device time(us): total=983 max=8 min= avg=
    23: compute region reached 500 times
        23: kernel launched 500 times
            grid: [998]  block: [256]
             device time(us): total=3,718 max=191 min= avg=7
            elapsed time(us): total=33,788 max=716 min=13 avg=67
    32: data region reached 500 times
        32: data copyin transfers: 500
             device time(us): total=3,828 max=11 min=6 avg=7
        38: data copyout transfers: 500
             device time(us): total=1,689 max=16 min= avg=3
    32: compute region reached 500 times
        32: kernel launched 500 times
            grid: [998]  block: [256]
             device time(us): total=3,953 max=21 min= avg=7
            elapsed time(us): total=33,598 max=352 min=14 avg=67
</code></pre>

<p>Note que en las partes donde dice &ldquo;data region&rdquo; en &ldquo;device time&rdquo; hemos invertido mucho tiempo, esto es pues cada paso de t envía los datos de la GPU a la CPU.</p>

<p><strong>Pregunta</strong></p>

<ul>
<li>¿Qué cree ud que debemos hacer con las matrices A1 y A2 para solventar este problema?
Realice lo mismo agregando sobre el bucle del tiempo una sección de manejo de datos de la siguiente manera:
<code>#pragma acc data copy(A1), create(A2)</code></li>
</ul>

<p>Ejecute nuevamente con la opción PGI_ACC_TIME=1</p>

<p><strong>Preguntas</strong></p>

<ul>
<li>¿Qué ocurrió con los tiempos en la región de datos?</li>
<li>¿Qué cree que significan las cláusulas copy y create?</li>
</ul>

<p><strong>Ejercicio</strong></p>

<ul>
<li>Resuelva la ecuación de laplace usando diferencias finitas hasta 500 pasos de tiempo con los mismo datos iniciales anteriores.</li>
<li>Pruebe aumentando el tamaño de la matriz y chequeando los tiempos de cálculo que tarda la <em>región de cómputo</em></li>
</ul>

					</div>
				</article>
                
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
							<span class="posted-on"><time class="entry-date published" date="2013-06-17 12:00:00 &#43;0000 &#43;0000">June 17, 2013</time></span>
						</div>
						<h1 class="entry-title"><a href="http://gerardogutierrez.co/en/courses/dev/" rel="bookmark">Development tools in GNU/Linux</a></h1>
					</header>
					<div class="entry-content">
						

<h1 id="under-translation">UNDER TRANSLATION</h1>

<h1 id="gnu-linux-development-tools">GNU/Linux Development tools</h1>

<h2 id="syllabus">Syllabus</h2>

<h3 id="building">Building</h3>

<ul>
<li><a href="#librerias">C libraries</a></li>
<li><a href="#make">Makefile</a></li>
<li><a href="#scons">Scons</a></li>
<li><a href="#cmake">CMake</a></li>
</ul>

<h3 id="version-control">Version Control</h3>

<ul>
<li><a href="#Subverion">Subversion</a></li>
<li><a href="#Mercurial">Mercurial</a></li>
<li><a href="#git">git</a></li>
</ul>

<h2 id="a-id-librerias-c-libraries-a"><a id="librerias">C libraries</a></h2>

<p>Realizaremos un ejercicio manual para la intriducción de un código que usaremos a través de todo el curso y para visualizar las ventajas de las herramientas automáticas de construcción.</p>

<p>Creemos los siguientes archivos de código en C:</p>

<p>libreriaPi.h</p>

<pre><code>void funcion (double *t, double *k, double *l);
</code></pre>

<p>libreriaPi.c</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

void funcion (double *t, double *k, double *l)
{
              (*t) += (*l)/(*k); 
              (*k) += 2.0; 
              (*l) *= -1.0; 

}
</code></pre>

<p>programaPi.c</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;libreriaPi.h&quot;

  
int main(int argc, char *argv[])
{
   double t, k = 3.0, l = -1.0;
   int i, s;

   if(argc &lt; 2){
     fprintf(stderr, &quot;%s &lt;no. de iteracines&gt;\n&quot;, argv[0]);
     exit(1);
   }
       
   t = 1.0; 
   for(i = 0, s = atoi(argv[1]); i &lt; s; i++)
   {
      funcion(&amp;t, &amp;k, &amp;l);
   }
   t *= 4; 

   printf(&quot;Valor de Pi calculado: %1.16f,  Valor de Pi en math.h: %.16f\n&quot;, t, M_PI); 
   printf(&quot;Diferencia: %.16f\n&quot;, fabs(M_PI - t)); 

   return 0; 
}
</code></pre>

<h3 id="creando-una-librería-estática">Creando una librería estática</h3>

<p>Una librería estática se crea con el archiver (ar) a partir de un archivo tipo objeto que creamos desde nuestro código en C. Los pasos a seguir son los siguientes :</p>

<p>Creamos un objeto a partir de nuestro código en C:</p>

<pre><code>gcc -c libreriaPi.c -o libreriaPi.o
</code></pre>

<p>Una vez tenemos nuestro fichero objeto llamamos al archiver(ar) para que nos genere la librería:</p>

<pre><code>ar rcs libpi.a libreriaPi.o
</code></pre>

<p><strong>NOTA:</strong>La librería tiene que empezar obligatoriamente con las tres letras lib y tiene que tener la extensión .a</p>

<h3 id="creando-una-librería-compartida">Creando una librería compartida</h3>

<p>En el caso de las librerías compartidas también es necesario crear un fichero objeto, hay que tener en cuenta que al crear el fichero con el mismo nombre que en el caso de la librería estática, estamos sobrescribiendo y eliminando el fichero anterior, algo conveniente teniendo en cuenta que la librería estática ya esta creada.</p>

<p>Creamos el objeto:</p>

<pre><code>gcc -c -fPIC libreriaPi.c -o libreriaPi.o
</code></pre>

<p>Una vez creado el objeto procedemos a crear la librería dinámica:</p>

<pre><code>gcc -shared -Wl,-soname,libpi.so.1 -o libpi.so.1.0.1  libreriaPi.o
</code></pre>

<p>El nombre de la librería tiene que empezar por lib y terminar en so y es opcional el numero de la versión</p>

<h3 id="enlazando-la-librería-estática">Enlazando la librería estática</h3>

<p>Para enlazar la librería estática a nuestro programa principal usamos la instrucción</p>

<pre><code>gcc -static programaPi.c -L. -lpi -o piEstatico
</code></pre>

<p>la opción -lpi indica el nombre de la librería sin las tres letras lib y sin su extensión. -l + nombre (sin lib y extensión )</p>

<h3 id="enlazando-la-librería-compartida">Enlazando la librería compartida</h3>

<p>Para ligar la librería dinámica usamos:</p>

<pre><code>gcc main.c -o piDinamico -L. -lpi
</code></pre>

<p>Como en el caso anterior la opción -lpi indica el nombre de la librería sin las tres letras lib y sin su extensión. -l + nombre (sin lib y extensión )</p>

<p><strong>NOTA:</strong> en el caso del ejecutable piDinamico cuando ejecutemos saldra</p>

<pre><code>./piDinamico: error while loading shared libraries: libpi.so: cannot open shared object file: No such file or directory
</code></pre>

<p>para solucionar esto ejecutamos</p>

<pre><code>export LD_LIBRARY_PATH=.
</code></pre>

<h2 id="a-id-make-makefile-a"><a id="make">Makefile</a></h2>

<p>make es una de las herramientas más usadas para la construcción de proyectos de software. Los usamos cada vez que descargamos unas fuentes para sistemas basados en linux. Existe una gran diferencia con otras formas de &ldquo;instalar&rdquo; un software en el sistema, como rpm o dpkg, éstos últimos comprimen los binarios en lo que llamamos un paquete (de redhat o debian respectivamente) y contienen también scripts de postconfiguración que ubicarán adecuadamente todos los archivos comprimidos.</p>

<p>Un archivo Makefile (el que es interpretado por make) contiene las instrucciones que logran  compilar y organizar los archivos de ejecución y configuración de un software en el sistema. Este archivo nos facilitará entonces automatizar el proceso de construcción hemos hecho a mano en la sección anterior.</p>

<p>El archivo makefile básico tiene la sintaxis</p>

<pre><code>objetivo: dependencias
    comando
</code></pre>

<p><strong>Nota:</strong> el espacio de abajo de la regla &ldquo;objetivo:dependencias&rdquo; debe existir y es un espacio tabulado</p>

<p>Aplicado a nuestro ejemplo anterior sería</p>

<pre><code>all: libreriaPi.c libreriaPi.h
    gcc libreriaPi.c programaPi.c -o pi.out
</code></pre>

<p>Llamaremos al archivo &ldquo;Makefile&rdquo;. En él hemos creado el objetivo &ldquo;all&rdquo; que make llamará por defecto.
Ejecutamos el comando</p>

<pre><code>make
</code></pre>

<p>Bien podríamos haber usado la sintaxis</p>

<pre><code>CC=gcc
pi.out: libreriaPi.c libreriaPi.h
    $(CC) libreriaPi.c programaPi.c -o $@
</code></pre>

<p>Aquí hemos introducido elconcepto de variables en make y un macro que viene por defecto. $@ reemplaza el nombre del objetivo, es decir, en este caso donde se encuentra $@ make pone pi.out.
Ejecutemos nuevamente el comando make.</p>

<p>También puden existir reglas que no sean de compilación. En este punto nos sería muy útil una función que nos limpie el ejecutable. Tenemos entonces el nuevo archivo Makefile</p>

<pre><code>CC=gcc
pi.out: libreriaPi.c libreriaPi.h
    $(CC) libreriaPi.c programaPi.c -o $@

clean: 
    rm -rf *.out
</code></pre>

<ul>
<li>¿Qué pasa si ejecutamos?</li>
</ul>

<pre><code>make
make clean
</code></pre>

<p>Aún no hemos hecho una compilación correcta pues no estamos creando una librería, creemos una regla de make para esto:</p>

<pre><code>CC=gcc
%.o:%.c
    $(CC) -c $&lt; -o $@
clean: 
    rm -rf *.out
</code></pre>

<p>En el ejemplo usamos % que refiere a el argumento de make que debe terner un .o al final para que siga esa regla. También usamos $&lt; que refiere a la primera cadena que se encuentra después de los :. Esta cadena completa es igual a</p>

<pre><code>gcc -c libreriaPi.c /o libreriaPi.o
</code></pre>

<p>Aún no hemos generado la librería, para ello debemos usar el archiver y tener un nombre con una sintaxis específica. Modifiquemos un poco el anterior makefile</p>

<pre><code>CC=gcc
libpi.a:libreriaPi.c libreriaPi.h
    $(CC) -c $&lt; -o libreriaPi.o
    ar rcs $@ libreriaPi.o
clean: 
    rm -rf *.out
</code></pre>

<ul>
<li>¿Por qué cambiar el objetivo del código objeto a la librería?</li>
</ul>

<p>Sólo nos falta hacer una regla para la compilación del programa princial, nuestro nuevo makefile queda</p>

<pre><code>CC=gcc

pi.out: programaPi.c libreriaPi.h libpi.a
    $(CC) -static $&lt; -L. -lpi -o $@

libpi.a:libreriaPi.c libreriaPi.h
    $(CC) -c $&lt; -o libreriaPi.o
    ar rcs $@ libreriaPi.o
clean: 
    rm -rf *.out *.a *.o
</code></pre>

<p>Finalmente nuestro proceso de compilación estático queda</p>

<pre><code>make clean
make libpi.a
make pi.out
</code></pre>

<p><strong>Ejercicios</strong>
* Realice un makefile pero con compilación dinámica.
* Observe el siguiente makefile y ejecute make all</p>

<pre><code>CC=gcc

all: clean libpi.a pi.out

pi.out: programaPi.c libreriaPi.h libpi.a
        $(CC) -static $&lt; -L. -lpi -o $@

libpi.a: libreriaPi.c $(DEPS)
        $(CC) -c $&lt; -o libreriaPi.o
        ar rcs $@ libreriaPi.o

clean:
        rm -rf *.out *.o *.a
</code></pre>

<ul>
<li>Si no lo ha haecho separe las fuentes en ./inc/ y ./src/ genere las librerías en ./lib/ y los ejecutables en ./bin/ con su makefile en .</li>
</ul>

<h2 id="a-id-scons-scons-a"><a id="scons">Scons</a></h2>

<p>Es una alternativa a make para el mismo objetivo. Está escrita en python y tiene su sintaxis pero la podemos usar para la construcción de cualquier tipo de proyecto. ASegúrese de que tiene instalado el comando scons o en sistemas debian ejecute como superusuario</p>

<pre><code>apt-get install scons
</code></pre>

<p>Como ejemplo básico compilaremos un hello world con el siguiente script que llamaremos SConstruct <del>#900:Exactamente con S y C mayúsculas</del></p>

<pre><code>entorno=Environment() #Esto es un comentario
entorno.Program(target='hello',source=['hello.c'])
</code></pre>

<p>En scons se debe crear un entorno de compilación. Éste contiene las variables que indican el compilador a usar, las opciones de enlazado y compilación, entre otras.</p>

<p>Para que nuestro conjunto de instrucciones sea interpretado simplemente ejecutamos el comando</p>

<pre><code>scons
</code></pre>

<p>Volvamos a nuestro ejemplo de calcular Pi y con él hagamos una compilación estática con un script de scons.
Debemos usar la función Library del entorno</p>

<pre><code>entorno=Environment() #Esto es un comentario
entorno.Library(target=&quot;libpi.a&quot;,source=&quot;libreriaPi.c&quot;)
</code></pre>

<p>Debemos obtener la salida</p>

<pre><code>scons: Reading SConscript files ...
scons: done reading SConscript files.
scons: Building targets ...
gcc -o libreriaPi.o -c libreriaPi.c
ar rc libpi.a libreriaPi.o
ranlib libpi.a
scons: done building targets.
</code></pre>

<p>Notemos que las líneas de compilación y de archivación son similares a las que teníamos antes. En este caso scons usa ranlib en vez de la opción s de ar para indexar el archivo.
Ahora agregaremos una línea para compilar el programa principal donde indicaremos que librería usar y donde se encuentra. Nuestro archivo SConstruct queda entonces</p>

<pre><code>entorno=Environment() #Esto es un comentario
entorno.Library(target=&quot;libpi.a&quot;,source=&quot;libreriaPi.c&quot;)
entorno.Program(target=&quot;piEstatico&quot;,source=&quot;programaPi.c&quot;,LIBS=['pi'],LIBPATH='.', LINKFLAGS='-static')
</code></pre>

<p>El argumento de la función LIBS recibe una lista de cadenas de caracteres que indican cada una de las librerías a usar.</p>

<ul>
<li>Si tuvieramos que usar la libreria math.h cómo tendría que cambiar ese argumento?
Debemos obtener una salida como</li>
</ul>

<pre><code>scons: Reading SConscript files ...
scons: done reading SConscript files.
scons: Building targets ...
gcc -o programaPi.o -c programaPi.c
gcc -o piEstatico -static programaPi.o -L. -lpi
scons: done building targets.
</code></pre>

<p>Cuya penúltima línea es la deseada.</p>

<p>Ahora para crear la librería dinámica y ligarla al programa principal usamos lafunción SharedLibrary</p>

<pre><code>entorno=Environment() #Esto es un comentario
entorno.SharedLibrary(target=&quot;libpi.so&quot;,source=&quot;libreriaPi.c&quot;)
entorno.Program(target=&quot;piDinamico&quot;, source=&quot;programaPi.c&quot;,LIBS='pi',LIBPATH='.')
</code></pre>

<p>y debemos obtener una salida como la siguiente</p>

<pre><code>scons: Reading SConscript files ...
scons: done reading SConscript files.
scons: Building targets ...
gcc -o libreriaPi.os -c -fPIC libreriaPi.c
gcc -o libpi.so -shared libreriaPi.os
gcc -o piDinamico programaPi.o -L. -lpi
scons: done building targets.
</code></pre>

<ul>
<li>Qué debemos ahcer para que ejecute correctamente?</li>
</ul>

<p>Si queremos limpiar nuestra área de trabajo, ya scons tiene por defecto la opción para ellos. Basta con digitar</p>

<pre><code>scons -c
</code></pre>

<p>Podemos usar todas las utilidades de python como la libreria os para crear carpetas y sus variables para no reescribir mucho código</p>

<pre><code>import os
if not os.path.exists(&quot;libs&quot;):
    os.makedirs(&quot;libs&quot;)
LIB=&quot;./libs/&quot;
entorno=Environment() #Esto es un comentario
entorno.SharedLibrary(target=LIB+&quot;libpi.so&quot;,source=&quot;libreriaPi.c&quot;)
entorno.Program(target=&quot;piDinamico&quot;, source=&quot;programaPi.c&quot;,LIBS='pi',LIBPATH=LIB)
os.environ[&quot;LD_LIBRARY_PATH&quot;]=LIB
os.system(&quot;./piDinamico 1000&quot;)
</code></pre>

<h2 id="a-id-cmake-cmake-a"><a id="cmake">CMake</a></h2>

<p>CMake es otra herramienta de construcción de software que nos permite facilmente abordar proyectos complejos con una facilidad aún mayor que los anteriores pues fue diseñado para soportar software con una jerarquía de directorios compleja.</p>

<p>Miremos su implementación básica con el código de hola mundo</p>

<pre><code>#include&lt;stdio.h&gt;

int main()
{
    printf(&quot;Hello world\n&quot;);
    return 0;
}

</code></pre>

<p>Nuestro archivo de cmake debe llamarse &ldquo;CMakeLists.txt&rdquo;</p>

<pre><code>add_executable(hello hello.c)
</code></pre>

<p>Ejecutamos el comando cmake indicándole donde se encuentra el archivo CMakeLists.txt</p>

<pre><code>cmake .
</code></pre>

<p>Este comando nos generó un Makefile que para obtener el ejecutable simplemente corremos el comando</p>

<pre><code>make
</code></pre>

<p>Podemos limpiar de algunas cosas nustro directorio</p>

<pre><code>make clean
</code></pre>

<p>No existe un cmake clean para borrar los archivos temporales de cmake, lo usual es crear una carpeta dentro del directorio del proyecto que por costumbre en los usuarios de cmake se llama build. Allí podremos correr el comando</p>

<pre><code>cmake ..
</code></pre>

<p>Y todos los archivos temporales de cmake quedarán en esa carpeta que podrá ser eliminada completamente una vez que no sea necesaria.</p>

<p>Ahora miremos u ejemplo un tanto más elaborado. Reutilicemos el código de calcular pi y agreguemos este archivo de cmake</p>

<pre><code>include_directories(.)
add_library(pi SHARED libreriaPi.h libreriaPi.c)
add_executable(findPi programaPi.c)
target_link_libraries(findPi pi)
</code></pre>

<p>En el archivo de cmake anterior hemos incluído la construcción de una librería dinámica que debemos enlazar al ejecutable.</p>

<p>Hagamos</p>

<pre><code>du -csh *
</code></pre>

<p>Y observemos el tamaño en disco de la librería y el ejecutable</p>

<p>Ahora hagamos una compilación estática modificando el archivo de cmake de la siguiente forma</p>

<pre><code>include_directories(.)
add_library(pi STATIC libreriaPi.h libreriaPi.c)
add_executable(findPi programaPi.c)
target_link_libraries(findPi  pi)
</code></pre>

<p>Miremos nuevamente el tamaño de los archivos y responda
* ¿Por qué el ejecutable es del mismo tamaño?
* ¿Está enlazando la librería correcta?
* ¿Cómo enlazamos estàticamente la librería?
* Hagamos que el archivo soporte nuestra jerarquía de directorios estandar.</p>

<p>Ahora que queremos instalar las librerías en ./lib y los ejecutables en ./bin agregamos las siguientes funciones a nuestro archivo CMakeLists.txt</p>

<pre><code>install(TARGETS pi DESTINATION lib)
install(TARGETS findPi DESTINATION bin)
</code></pre>

<p>Al agregar esta nueva función cmake crea en el Makefile la regla para instalar las librerías y ejecutables en este caso. Intentemos ejecutar la regla</p>

<pre><code>make install
</code></pre>

<p>Observemos que cmake intenta instalar en las rutas del sistema, nosotros queremos ubicaro en una ruta personal dentro de la carpeta del proyecto. Esto se hace ejecutando cmake de la siguiente forma</p>

<pre><code>cmake .. -DCMAKE_INSTALL_PREFIX=..
</code></pre>

<p>Queremos ahora compilar un c&rsquo;odigo que realizamos con una librería externa. TOmemos el siguiente código de una transformada de Fourier con gsl</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#include&lt;gsl/gsl_errno.h&gt;
#include&lt;gsl/gsl_fft_real.h&gt;

double function(double x, double freq1, double freq2)
{
    return sin(freq1*x)+sin(freq2*x);
}


int main()
{
    int i,n=1000;
    double data[n];
    FILE *original,*transformed;
    original = fopen(&quot;original.dat&quot;,&quot;w&quot;);
    transformed = fopen(&quot;transformed.dat&quot;,&quot;w&quot;);

    gsl_fft_real_wavetable * wavetable;
    gsl_fft_real_workspace * workspace;

    wavetable = gsl_fft_real_wavetable_alloc(n);
    workspace = gsl_fft_real_workspace_alloc(n);

    for(i=0;i&lt;n;i++)
    {
        data[i]=function(4*M_PI*i/n,0.9,50.8);
        fprintf(original,&quot;%f\n&quot;,data[i]);
    }

    gsl_fft_real_transform(data,1,n,wavetable,workspace);

    for(i=0;i&lt;n;i++)
    {
        fprintf(transformed,&quot;%f\n&quot;,data[i]);
    }


    fclose(original);
    fclose(transformed);
    return 0;
}
</code></pre>

<p>Qué pasa si usamos un archivo CMakeLists.txt como el inicial?</p>

<pre><code>add_executable(fft fft_gsl.c)
</code></pre>

<p>Una opción podría ser enlazar las librerías que ya conocemos su nombre modificando el archivo CMakeLists.txt de la siguiente forma</p>

<pre><code>add_executable(fft fft_gsl.c)
target_link_libraries(fft gsl gslcblas m)
</code></pre>

<p>Con esta solución tenemos un par de problemas, tenemos que saber de antemano si la librería se encuentra instalada y si la lista de librerías a enlaar es muy grande la tenemos que copiar entera como en un make.</p>

<p>Otra forma puede ser usando el comando gsl-congif modificando el cmake de la siguiente manera</p>

<pre><code>find_program(GSL_CONFIG gsl-config)
if(GSL_CONFIG)
  execute_process( COMMAND ${GSL_CONFIG} --libs OUTPUT_VARIABLE GSL_LIBS )
endif()
add_executable(fft fft_gsl.c)
target_link_libraries(fft ${GSL_LIBS})
</code></pre>

<p>Una alternativa está en crear un módulo de cmake que encuentre automáticamente las librerías y ubique en una variable la ubicación y los sufijos de enlazado. Creemos una carpeta que se llame cmake_modules en la raíz del proyecto y allí creemos un archivo llamado FindGSL.cmake con el contenido siguiente</p>

<pre><code>find_path (GSL_INCLUDES gsl/gsl_math.h)
find_library (M_LIB m )
find_library (GSL_LIB NAMES gsl)
set (GSL_CBLAS_LIB &quot;gslcblas&quot;)
set (GSL_LIBRARIES &quot;${GSL_LIB}&quot; &quot;${GSL_CBLAS_LIB}&quot; &quot;${M_LIB}&quot;)
</code></pre>

<p>Y modificamos el CMakeLists.txt de la siguiente forma</p>

<pre><code>set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} &quot;${CMAKE_SOURCE_DIR}/cmake_modules/&quot;)
find_package(GSL)
add_executable(fft fft_gsl.c)
target_link_libraries(fft ${GSL_LIBRARIES})
</code></pre>

<p><strong>Ejercicios</strong></p>

<ul>
<li>Para una transformada fftw haga el módulo que encuentre la librería y ubique en variables las directivas d e enlazado.</li>
</ul>

<h2 id="a-id-subversion-subversion-a"><a id="Subversion">Subversion</a></h2>

<p>El repositorio no contiene los archivos como tales, están codificados eficientemente de tal manera que se pueda acceder a una copia de cualquier versión de los archivos que han sido guardados durante la historia del repo.
Para poder trabajar en el repositorio necesitamos realizar una copia de trabajo local, para esto hacemos</p>

<pre><code>svn checkout svn+ssh://gerardo.gutierrez@c3.itm.edu.co:/home/gerardo.gutierrez/control_de_versiones/svn/pi
</code></pre>

<p>Verán una jerarquía de directorios determiandas por el grupo de desarrollo. Generalmente son las tres que se encuentran allí:
* trunk: la rama principal de trabajo
* branches: ramas adicionales donde se realizan desarrollos paralelos
* tags: Contiene la información de versionado del proyecto</p>

<p>Para realizar una actualización del software descargado usamos el comando</p>

<pre><code>svn update
</code></pre>

<p>Ahora agreguemos el archivo del programa principal al repositorio. Para hacer que nuestra copia de trabajo tenga registro del archivo debemos hacer</p>

<pre><code>svn add programaPi.c
</code></pre>

<p>Ahora para actualizar nuestra copia remota hacemos</p>

<pre><code>svn commit 
</code></pre>

<p>E ingresa un mensaje de commit reportando los cambios que se realizaron al proyecto.</p>

<p>Si uno quisiera hacer una rama para desarrollar alguna característica nueva sin dañar la rama principal podemos hacer una operación de copia</p>

<pre><code>svn copy svn+ssh://gerardo.gutierrez@c3.itm.edu.co:/home/gerardo.gutierrez/control_de_versiones/svn/pi/trunk svn+ssh://gerardo.gutierrez@c3.itm.edu.co:/home/gerardo.gutierrez/control_de_versiones/svn/pi/branches/rama_make
</code></pre>

<p>Hagamos un cambio a nuestra rama agregando el makefile que teníamos posteriormente</p>

<pre><code>svn add Makefile
svn commit
</code></pre>

<p>En este momento tenemos una rama que está con un desarrollo adelantado con respecto a la rama principal, podemos complicar un poco más el asunto. Supongamos que el desarrollador principal del proyecto creó un readme <strong>en la rama principal</strong></p>

<pre><code>touch README
svn add README
svn commit
</code></pre>

<p>Ahora nuestra rama_make no está sincronizada con la principal. Cuando vayamos a hacer la actualización de la rama principal con el nuevo desarrollo debemos asegurarnos que la rama de trabajo está al día con respecto a la pincipal. Esto se hace con la operación merge</p>

<pre><code>cd branches/rama_make
svn merge svn+ssh://gerardo.gutierrez@c3.itm.edu.co:/home/gerardo.gutierrez/control_de_versiones/svn/pi/trunk
svn commit
</code></pre>

<p>Ya tenemos la rama actualizada y podemos incluir nuestro nuevo desarrollo a la rama principal sin temor a generar conflictos.</p>

<pre><code>svn merge ../branches/rama_make
</code></pre>

<p>Algunos comandos muy útiles son</p>

<pre><code>svn log
svn remove
svn help
</code></pre>

<h2 id="a-id-mercurial-mercurial-a"><a id="Mercurial">Mercurial</a></h2>

<p>Antes de realizar cualquier operación con mercurial, debemos generar un nombre de usuario en su sistema. Para esto ejecutamos el comando</p>

<pre><code>hg config --edit
</code></pre>

<p>Para hacer una copia de trabajo del repositorio remoto hacemos</p>

<pre><code>hg -v clone ssh://gerardo.gutierrez@c3.itm.edu.co/control_de_versiones/mercurial/pi/
</code></pre>

<p>Supongamos de nuevo que queremos agregar el archivo del programa principal</p>

<pre><code>hg add programaPi.c
hg commit
hg push
</code></pre>

<p>Mercurial como todos los sistemas de control de versiones le pedirá un mensaje de commitdonde usted deberá documentar los cambios realizados. con el comando push lo que hacemos es actualizar el repositorio remoto con los cambios en la copia de trabajo.</p>

<p>Si necesitamos actualizar la copia de trbajo porque alguien hizo un cambio ejecutamos</p>

<pre><code>hg pull
</code></pre>

<p>Queremos ahora empezar el desarrollo de la rama que incluirá un makefile</p>

<pre><code>hg branch rama_make
</code></pre>

<p>Nos devuelve un mensaje indicando que nuestra copia de trabajo ahora será la nueva rama creada. Para sincronizar los cambios debemos hacer</p>

<pre><code>hg commit
hg push
</code></pre>

<p>Ahora incluyamos el archivo Makefile. Recordemos</p>

<pre><code>hg add Makefile
hg commit
hg push
</code></pre>

<p>Si queremos volver a la rama principal(default) usamos el comando update seguido del nombre de la rama</p>

<pre><code>hg update default
</code></pre>

<p>Supongamos de nuevo el problema anterior. La rama en la que estoy desarollando estaba al día con la rama principal, pero alguien le agregó algo nuevo a esta última. Debemos actualziar la rama de trabajo para poder luego hacer el merge de manera correcta. En la rama de desarrollo hacemos</p>

<pre><code>hg heads
hg merge #changeset 
hg commit
hg push
</code></pre>

<p>Para actualizar la rama principal realizamos la misma operación pero estando en ella.</p>

<p>Algunos otros comando útiles</p>

<pre><code>hg parents
hg status
hg sum
hg remove
</code></pre>

<h2 id="a-id-git-git-a"><a id="git">git</a></h2>

<p>Un sistema de control de versiones le permite tener registro de los cambios realizados sobre un conjunto de archivos, restaurar una versión previa y continuar su trabajo desde allí. El conjunto de achivos y su historia se llama repositorio.
Git es un sistema de control de versiones distribuido, cada copia (clon) del repositorio es un repositorio en sí, es decir, al hacer una copia del respositorio se copia también toda su historia.</p>

<p>Para crear el repositorio con el contenido de la carpeta vamos a la lĺinea de comandos y hacemos:</p>

<pre><code>$ git init --bare /ruta/a/la/carpeta/documento
</code></pre>

<p>Esto creo un repositorio abstracto, contiene solamente los archivos que vimos anteriormente en la carpeta .git, esta vez trabajaremos con un documento en latex, entonces he llamado a nuestro repositorio &ldquo;documento&rdquo;</p>

<p>Debe observar un mensaje de que ha sido creado el repositorio:</p>

<pre><code>Initialized empty Git repository in /ruta/a/la/carpeta/documento/.git/
</code></pre>

<p>Si entramos a la carpeta y listamos los archivos ocultos vemos que se ha creado una carpeta .git, esta carpeta contiene todos los registros de la ubicación del repositorio (local o en la red) y los registros de cambios en los archivos.</p>

<p>Ahora, ubicados FUERA de la carpeta donde se encuentra nuestro repositorio, creemos una copia de éste con el comando:</p>

<pre><code>$ git clone documento clon1
</code></pre>

<p>Nos debe salir un mensaje indicándonos que hemos hecho un clon de un repositorio vacío:</p>

<pre><code>warning: You appear to have cloned an empty repository.
</code></pre>

<p>Si listamos los archivos veremos que tenemos una nueva llamada clon, si listamos todos los archivos allí, veremos que también existe una carpeta oculta .git pero no existe ningún archivo, copiemos el archivo en LaTEX que descargamos de [<a href="http://gfif.udea.edu.co/~gerardo/articulo.tex|aquí" target="_blank">http://gfif.udea.edu.co/~gerardo/articulo.tex|aquí</a>].
Para agregar dicho archivo al clon del repositorio hacemos el siguiente comando dentro de la carpeta clon:</p>

<pre><code>$ git add articulo.tex
</code></pre>

<p>Se deben agregar todo los archivos que van a pertenecer al repositorio pues es tarea del usuario discriminar que se va a reservar y que no, por ejemplo, los archivos temporales, los datos o los binarios no se suelen guardar en un repositorio.</p>

<p>En los sistemas de control de versiones es importante, necesario y obligatorio dejar siempre un mensaje cada que se reporta un cambio en los archivos, al proceso de reporte de cambios lo llamamos <strong>commit</strong> y al mensaje <strong>mensaje de commit</strong></p>

<pre><code>$ git commit
</code></pre>

<p>Este comando abrirá un editor de texto por defecto y reportará los cambios agregados, es decir, si no agregamos el archivo de latex éste no será reservado en nuestro repositorio.</p>

<p>Hasta este punto todavía no tenemos la información en el repositorio, solo en su copia, para enviarla al repo realizamos el comando</p>

<pre><code>$ git push origin master
</code></pre>

<p>Donde push refiere a &ldquo;empujar&rdquo; los cambios, estrictamente hablando, envía el commit al repositorio original.</p>

<p>Origin es la forma en la que git guarda la ruta al repositorio original, lo podemos ver haciendo:</p>

<pre><code>cat .git/config
</code></pre>

<p>Esta ruta puede ser local o en un servidor remoto como C3.
Master es la rama a la que estamos enviando el commit, ahondaremos en cuanto a las ramas más adelante.</p>

<p>Uno de las funciones principales de los sistemas de control de versiones es la sincronización del trabajo en diferentes ordenadores, supongamos ahora que queremos continuar nuestro trabajo desde la casa, haremos entonces un nuevo clon allí, e nuetro caso, hagámoslo en otra carpeta:</p>

<pre><code>$ git clone clon2
</code></pre>

<p>Vemos que también el archivo.tex ha sido incluido.</p>

<p>Creemos allí una carpeta que llamaremos img, donde vamos a guardar las imágenes del artículo.
* ¿Qué pasa si agregamos la carpeta vacía?
Descarguemos cualquier imagen de la red y ubiquémosla allí. Observemos ahora el estado del nuestro repositorio con el comando:</p>

<pre><code>$ git status
</code></pre>

<ul>
<li>¿Qué pasa si en este punto realizamos un push?</li>
<li>Agreue la carpeta.¿Es recursivo el comando &ldquo;git add&rdquo;?</li>
<li>Realice el commit.</li>
<li>Realice el push.</li>
</ul>

<p>Volvamos ahora a la carpeta clon1, si lsitamos los archivos allí vemos que la copia está desactualizada, le falta la carpeta de imagenes.
Para actualizar una copia del repositorio podemos hacer:</p>

<pre><code>$ git pull
</code></pre>

<p>Supongamos ahora que los cambios realizados no son satisfactorios y queremos volver a una versión anterior, esto es, nos queremos devolver a un commit previo. Primero debemos conocer cual es el identificador del commit:</p>

<pre><code>$ git log
</code></pre>

<p>Veremos un mensaje del tipo:</p>

<pre><code>commit 40997ab90bd69f31d461a9ab0052664f17fb5ef1
Author: usuario &lt;usuario@localhost&gt;
Date:   Fri May 16 01:09:31 2014 -0500  
                                        
    Agregamos imagenes         
                                               
commit 349dd0e3a1f24b39ed43d03f70273b319cf00fdb
Author: muzgash &lt;usuario@localhost&gt;      
Date:   Fri May 16 01:09:31 2014 -0500
 
    Agregamos el archivo principal del artículo
</code></pre>

<p>El número enorme luego de la palabra commit es el identificador de dicho reporte. Para volver a la primera versión por ejemplo basta con pegar los primeros caracteres del identificador en el siguiente comando:</p>

<pre><code>$ git reset --hard 349dd
</code></pre>

<ul>
<li>Revisemos el archivo articulo.tex y el log de git.</li>
</ul>

<p>Vemos que sucede con la siguiente sucesión de eventos:
* Hagamos una modificación en clon1 con su respectivo commit pero sin push
* Hagamos también una modificación diferente en clon2 consu respectivo commit.
* En cualquier copia hagamos un pull.</p>

<p>Observemos la salida del comando:</p>

<pre><code>$ git branch -a
</code></pre>

<p>Esto nos reporta las <strong>ramas</strong> o branches disponibles en el repositorio, una rama es un espacio de trabajo dentro del repositorio, por defecto se comienza a trabajar en la rama principal que se llama <strong>master</strong>. Cuando se van a realizar cambios o se va a probar algo nuevo en los archivos de trabajo, por lo general se hace en una rama diferente a la principal y luego que todo esté probado se incluye en ésta última.</p>

<p>Para crear una rama usamos el comando</p>

<pre><code>$ git checkout -b nombre_rama
</code></pre>

<p>La opción &lsquo;b nos lleva de una vez a la rama recién creada. Esta rama se crea en el repositorio local, para subirla al repositorio remoto hacemos</p>

<pre><code>$ git push origin nombre_rama
</code></pre>

<p>Se creará una rama remotamente y se añadirán allí los cambios locales realizados.
Para unir dos ramas usamos</p>

<pre><code>$ git merge rama

</code></pre>

<p>Aquí estamos trayendo los cabios realizados en la rama del comando con la rama activa. En estos casos pueden suceder conflictos que git reporta como una modificación en cada archivo.</p>

<p><strong>Ejercicios</strong></p>

<ul>
<li>Cree una cuenta en github</li>
<li>Realice un clone del repositorio <a href="https://github.com/muzgash/constants" target="_blank">https://github.com/muzgash/constants</a></li>

<li><p>Cree una rama donde creará una nueva librería que realizará una de estas tareas</p>

<ul>
<li>Constante de Napier
<div>$$e=\sum\limits_{n=0}^\infty \frac{2n+2}{(2n+1)!}$$</div></li>

<li><p>Número Áureo
<div>$$\phi_{n+1}=\phi_n-\frac{\phi_n^2-\phi_n-1}{2\phi_n-1}$$</div></p></li>

<li><p>Constante de Euler-Mascheroni
<div>$$\gamma=\lim<em>{n\to\infty}\sum\limits</em>{k=1}^n \frac{1}{k}-ln(n)$$</div></p></li>

<li><p>Constante de Catalan
<div>$$G=\sum\limits_{n=0}^\infty \frac{(-1)^n}{(2n+1)^2}$$</div></p></li>
</ul></li>

<li><p>Modifique el archivo principal de código donde probará dicha librería y el archivo CMakeLists.txt para la compilación.</p></li>

<li><p>Haga una actualización de su código remotamente y esté al tanto de las ramas de sus compañeros.</p></li>

<li><p>Cuando todas las ramas estén listas, haga un merge de cada una en su repositorio, resuelva los conflictos necesarios y realice un push con el código de tal forma que se pueda compilar y correr correctamente.</p></li>
</ul>

					</div>
				</article>
                
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
							<span class="posted-on"><time class="entry-date published" date="2013-06-17 12:00:00 &#43;0000 &#43;0000">June 17, 2013</time></span>
						</div>
						<h1 class="entry-title"><a href="http://gerardogutierrez.co/en/courses/bash/" rel="bookmark">GNU/Linux and BaSH</a></h1>
					</header>
					<div class="entry-content">
						

<h1 id="under-translation">UNDER TRANSLATION</h1>

<p>#!/bin/bash</p>

<p><strong>Duration:</strong> 40 Hours<br />
<strong>Teacher:</strong> Gerardo Gutiérrez<br />
<strong>Contacto:</strong>  muzgash@gmail.com</p>

<h2 id="sylabus">Sylabus</h2>

<ul>
<li><strong>Command Line</strong>

<ul>
<li><a href="#cli">Command Line</a></li>
<li><a href="#envirionment">Environment variables</a></li>
<li><a href="#redireccion">Redirectoins and quoting</a></li>
<li><a href="#regexp">Regular Expressions</a></li>
<li><a href="#sed">SED</a></li>
<li><a href="#awk">AWK</a></li>
</ul></li>
<li><strong>Bash - Scripting</strong>

<ul>
<li><a href="#scripting">Scripting</a><br /></li>
<li><a href="#stream">Loops</a><br /></li>
<li><a href="#files">File IO</a><br /></li>
<li><a href="#bc">bc</a><br /></li>
<li><a href="#arrays">Arrays</a></li>
</ul></li>
<li><strong>“Parallel” BaSH</strong><br />

<ul>
<li><a href="#torque">BaSH &amp; qsub</a><br /></li>
</ul></li>
</ul>

<h2 id="a-name-cli-a-command-line"><a name="cli"></a>Command Line</h2>

<p>In order to get familiar with the system, in this section we are going to do basic commands that help us in any unix-like system.</p>

<pre><code>$ whoami
$ pwd
$ mkdir carpeta
$ cd carpeta
$ touch carpeta/archivo
$ ls -r carpeta/
$ asd
</code></pre>

<p>Every command has a manual inside the system, the set of manuals is called &ldquo;manpages&rdquo;. Let&rsquo;s see</p>

<pre><code>$ man ls
</code></pre>

<p>To delete files or move between folder we can use these commands with some options. Let&rsquo;s explore:</p>

<pre><code>$ rm
$ mv
$ cd ~
$ cd -
$ cd /
</code></pre>

<p>In the previous box we used some arguments for the commands that are called wildcards:</p>

<ul>
<li>~ is the route to the user folder (also called home). It is an alias for /home/user</li>
<li>- is the previous folder</li>
<li>/ is the main folder of the system (called root folder)</li>
</ul>

<p>The edistribution of files and folders of linux systems is somewhat similar through the distributions. Here we are going to describe the most important
|/bin|Contains the base software for the system|
|/etc|Contains configuration files|
|/dev|Is where the kernel is going to look for peripherals or devices (everything in linux is a file)|
|/home|It is where the users folders are stored|
|/media|Contains the folders where the usb drives or cdroms are going to be placed (mounted)|</p>

<p>To see the content of a file you can use commands like cat, more or less. Let&rsquo;s explore some files</p>

<pre><code>$ more /etc/passwd
$ less ~/.bashrc
$ cat /dev/random
</code></pre>

<p>We haven&rsquo;t defined whats a command. A command can be:
* An executable program in /usr/bin or builint the intereter (like cd)
* A BaSH script
* An alias</p>

<p>THe following instructions will give you information about commands just like &ldquo;man&rdquo;</p>

<pre><code>$ type
$ which
$ apropos
$ info
$ whatis
</code></pre>

<p>Commands can be executed in sequence by using the separator &ldquo;;&rdquo;, What does the following line do?</p>

<pre><code> $ alias mkcd='mkdir test;cd test'
</code></pre>

<p>The alias command can rename another commando or set of them. In this example we are going to rename mkdir and cd command to mkcd to create a folder and access it immediately.</p>

<p>Linux comes with a default compression method called &ldquo;tarball&rdquo;, let&rsquo;s execute the following commands:</p>

<pre><code>$ touch foo
$ touch bar
$ tar -cf foobar.tar foo bar
$ ls -l *
</code></pre>

<p>In this block we created two empty files, then compressed them with the command tar (see man). Why do the empty files use 0 bits and the compressed versions use more bits?</p>

<h3 id="a-name-environment-a-environment-variables"><a name="environment"></a>Environment variables</h3>

<p>Linux pone a disposición del usuario información en una sesión de trabajo, información como donde se encuentran los comandos y los comandos mismos. Ésta la podemos categorizar en: Comandos y variables.
Las variables se subdividen en varibales del shell(que veremos más adelante) y variables de entorno que investigamos así:</p>

<pre><code>$ printenv
</code></pre>

<p>Se puede ver el contenido de la variable usando el comando echo:</p>

<pre><code>$ echo $USER
</code></pre>

<p>He aquí algunas de las variables con su descripción:
|HOME|La ruta al home del usuario|
|USER|El usuario actual|
|PWD|El directorio de trabajo actual|
|TZ|La zona horaria|
|LANG|El idioma|
|PATH|Lista de rutas donde el sistema busca comandos|</p>

<p>Cuando iniciamos una sesión el programa BaSH comienza y lee archivos de configuración que definen el entorno, estos archivos se llaman archivos de arranque (startup files) y depende del sistema pueden ser:</p>

<ul>
<li>/etc/profile</li>
<li>/etc/bash.bashrc</li>
<li>~/.bash_profile</li>
<li>~/.bash_login</li>
<li>~/.profile</li>
<li>~/.bashrc</li>
</ul>

<p>Estos archivos pueden cambiar dependiendo del tipo de shell o de distribución de linux que estemos usando.</p>

<p>Para modificar el entorno basta con editar los archivos anteriormente mencionados para que realicen la tarea que queramos o si simplemente queremos cambiar una variable lo hacemos en 2 pasos: creando la variable y exportándola. Analicemos el ejemplo:</p>

<pre><code>$ saludo=&quot;hola &quot;
$ echo $saludo
hola 
$ saludo=$saludo&quot;mundo&quot;
$echo $saludo
hola mundo
</code></pre>

<p>Aquí creamos la variable a través del caracter &ldquo;=&rdquo; y mostramos que se pueden concatenar.
Hasta ahora no hemos exportado la variable, pero ella existe en el entorno de trabajo. ¿Qué pasa si abro una nueva sesión de BaSH(ejecute el comando bash) y busco la variable?
Exportemos ahora la variable con el comando:</p>

<pre><code>export $saludo
</code></pre>

<p>¿Qué pasa ahora si abro una ===nueva=== sesión de BaSH?</p>

<p><strong>HOMEWORK</strong>
*Agregue a su .bashrc un alias para conectarse al servidor de la sala cluster c3.
*Discutamos la siguiente secuencia de comandos:</p>

<pre><code>$ mkdir bin
$ echo &quot;ls -a -l --color&quot; &gt; bin/ll
$ chmod u+x bin/ll
$ PATH=$PATH:$PWD/bin
$ export PATH
</code></pre>

<p><strong>ANSWER</strong></p>

<pre><code>$ echo &quot;alias ='ssh usuario@c3.itm.edu.co -X'&quot; &gt;&gt; ~/.bashrc
La secuencia crea un directorio bin en $PWD.
Redirecciona el comando ls -al con color a un achivo nuevo dentro de esta carpeta.
Vuelve éste ejecutable solo para $USER
Redefine la variable de entorno $PATH al agregarle la carpeta $PWD/bin y exportandola.
</code></pre>

<h3 id="a-name-redireccion-a-redirections-and-quoting"><a name="redireccion"></a>Redirections and Quoting</h3>

<p>En las secciones anteriores hemos usado un poco de redirecciones de una manera muy básica, pero esta es una de las herramientas más importantes de los sitemas Unix.
Todos los comandos producen algún mensaje, ya sea de error o el resultado de la operación que realiza. Estos mensajes pasan a través de un flujo (stream) de datos llamado <strong>stderr</strong>(de standard error) y <strong>stdout</strong> (de standard output), el primero para el error y el segundo para el resultado del comando.
Adicionalmente la información que es requerida por el comando se toma del flujo llamado <strong>stdin</strong>(de standard input).</p>

<p><strong>Las redirecciones</strong> redefinen a donde van los flujos de salida (stdout y stderr) y de donde proviene el de entrada.
Creemos un archivo con el contenido del home y su espacio en disco:</p>

<pre><code>$ du -csh ~/* &gt; home.log
$ cat home.log
</code></pre>

<p>Con el caracter «mayor que» estamos redirigiendo el stdout del comando du con sus opciones, al archivo home.log. Tratemos de hacer lo mismo pero con un mensaje de error:</p>

<pre><code>$ asd
$ asd &gt; error.log
$ cat error.log
</code></pre>

<p>El comando asd no existe pero el error salió en pantalla a diferencia del caso anterior donde dirigimos el flujo a un archivo. Veamos la instrucción</p>

<pre><code>$ asd 2&gt; error.log
$ cat error.log
</code></pre>

<p>El sistema tiene unos indicadores numéricos para estos flujos, como vimos en el ejemplo anterior el 2 corresponde a stderr, 1 y 0 a stdout y stdin respectivamente.
Para redirigir ambos flujos de salida a un archivo podemos usar estos comandos:</p>

<pre><code>$ cat /etc/sh* &gt; ls-output 2&gt;&amp;1
$ cat /etc/sh* &amp;&gt; ls-output
</code></pre>

<p>Note que el orden de las redirecciones es importante. ¿Qué pasa si redireccionamos a /dev/null? ¿Qué utilidad podría tener esto?</p>

<p>Para llevar el stdout de un comando al stdin de otro podemos usar un operador llamado <strong>pipe</strong>, vemoslo en un ejemplo:</p>

<pre><code>$ ls /home/ | wc -l
</code></pre>

<p>El comando wc cuenta los renglones del stdin, en este caso la salida del comando ls, es decir, cuenta el número de usuarios.</p>

<p><strong>HOMEWORK</strong>
Investiguemos los comandos: grep, sort, uniq, tee, tail y head.
Descargue el [<a href="http://c3.itm.edu.co/bash/actividad2.tar.gz|archivo" target="_blank">http://c3.itm.edu.co/bash/actividad2.tar.gz|archivo</a>], descomprímalo y:
* ¿Cuantos pacientes hay en el archivo patients.csv?
* Usando solo una línea de comandos, haga una lista de todas las palabras diferentes que encuentra en el archivo words y cuéntelas.
* Usando solo una línea de comandos, encuentre todas las ocurrencias de zzzz, cuéntelas y cree un archivo con todos los datos excepto estos.
* En una sola línea de comandos, cree un archivo de 100 datos intermedios del archivo att.dat y muéstrelos en terminal.</p>

<p><strong>ANSWERS</strong></p>

<pre><code>$ whatis {grep,sort,uniq,tail,head}
$ wget http://c3.itm.edu.co/bash/actividad2.tar.gz; tar -zxvf actividad2.tar.gz
$ grep -i gsp patients.csv | wc -l
$ sort words | uniq | wc -l
$ N=$(cat words|wc -l);grep -v zzzz words&gt;wordz.txt;n=$(cat wordz.txt|wc -l);echo $(($N+$n))
$ N=$(cat att.dat|wc -l);head -n $(($N/2+50)) att.dat | tail -n 100 &gt; 100data.txt
</code></pre>

<p>En varias ocasiones hemos usado el caracter ~ para denotar la ruta al home, hagamos:</p>

<pre><code>$ ls ~/..
$ echo /*
</code></pre>

<p>Vemos que el caracter * en echo no imprime un « * » sino las carpetas ubicadas en /, como si fuera un ls. A esta forma de usar el * y ~ se les llama <strong>expansiones</strong>.
|Expanssion|Description|Example|
|&mdash;|&mdash;:|:&mdash;|
|<code>$((expresion))</code>|Evalua una expresión aritmética|<code>$ echo $(( 2**8 ))</code>|
|<code>{a,b,c}</code>|Crea una colleción de argumetos con a, b y c |<code>$ mkdir folder_{a,b,c}</code>|
|<code>{1..5}</code>|Crea una colleción de argumentos con los números del 1 al 5 |<code>$ touch photo_{1..5}</code>|
|<code>{M..D}</code>|También funciona con letras |<code>$ echo {M..D}</code>|</p>

<p>Algo que usaremos mucho en el capítulo de scripts es el <strong>encomillado</strong>. Los caracteres especiales que hemos usado en algunas ocasiones no dan los resultados esperado, por ejemplo:</p>

<pre><code>$ mkdir nombre espaciado
$ echo hola             mundo
$ echo El PIB per capita es US$7.7
</code></pre>

<p>Para evitar estos errores usaremos <strong>comillas dobles</strong>, con éstas cualquier caracter especial que esté dentro de ellas perderá su significado, y será tratado con un caracter común.</p>

<pre><code>$ mkdir &quot;nombre espaciado&quot;
$ ls -l &quot;nombre espaciado&quot;
$ echo &quot;hola           mundo&quot;
</code></pre>

<p>Excepciones a esta regla son «$»,«\»(backslash) y «`»(comilla invertida o acento grave).</p>

<pre><code>$ echo &quot;El PIB per capita es US$$((3+4)).$((2*3))&quot;
$ echo &quot;2 y 2 son $((2+2)), 4 y 2 son $((4+2))&quot;
</code></pre>

<p>Si necesitamos retirar todas las influencias de los caracteres especiales usamos <strong>comillas simples</strong>:</p>

<pre><code>$ echo 'El PIB per capita es US$$((3+4)).$((2*3))'
$ echo '2 y 2 son $((2+2)), 4 y 2 son $((4+2))'
</code></pre>

<p>Sin embargo a veces necesitamos que solo uno de los caracteres especiales no sea interpretado como tal, para esto usamos «\»(backslash) llamado el caracter de escape:</p>

<pre><code>$ echo &quot;El PIB per capita es US\$$((3+4)).$((2*3))&quot;
</code></pre>

<h3 id="a-name-regexp-a-regular-expressions"><a name="regexp"></a>Regular Expressions</h3>

<p>Las expresiones regulares son un conjunto de caracteres que determinan un patrón. Estos caracteres servirán para encontrar líneas de texto específicas con un patrón particular.
Las expresiones regulares se componen de 3 tipos de metacaracteres:
* <strong>Anchors</strong>: Especifican la posición del patrón en relación a una línea de texto.
* <strong>Conjunto de caracteres</strong>: Especifican uno o más caracteres en una sola posición.
* <strong>Modificadores</strong>: Especifican cuantas veces el caracter anterior será repetido.</p>

<p>Las anclas <code>^ y $</code> significan el principio y el final de una línea, es decir <code>^asd</code> buscará todas las líneas que comiencen con asd y <code>asd$</code> buscará todas las líneas que terminen con asd, veamos un ejemplo:</p>

<pre><code>$ ls /usr/bin/ | grep '^zip'
$ ls /usr/bin/ | grep 'zip$'
</code></pre>

<p>Un solo caracter cualquiera es reemplazado por <strong>.</strong>, un conjunto de caracteres es determinado entre corchetes:</p>

<pre><code>$ grep -i '^[ae][ou]$' /usr/share/dict/spanish
$ grep -i '^[a-w]...t$' /usr/share/dict/spanish
</code></pre>

<p>Estos últimos tienen sus excepciones
|Expresión regular|reemplaza|
|&mdash;|:&mdash;:|
|<code>[]}</code>|<code>Los caracteres [ y ]</code>|
|<code>[1]</code>| El caracter 1|
|<code>[^0-9]</code>| Cualquier caracter excepto un número|
|<code>[a-z]]</code>| <code>Cualquier letra seguida de ]</code>|
|<code>[]0-9]</code>| <code>Cualquier número o ]</code>|</p>

<p>Observamos que <code>^</code> dentro de los corchetes niega la expresión regular. Elcaracter ** * ** reemplaza cualquiér número(0 o más) de ocurrencias del caracter que le precede.</p>

<p>Para encontrar un número de veces la expresión en la línea usamos los caracteres <strong>{</strong> y <strong>}</strong>, por ejemplo <code>'^A\{4,\}'</code> encuentra la línea con 4 o más aes.
Encontramos una palabra completa insertándola entre <strong>&lt;</strong> y <strong>&gt;</strong>.
Las expresiones regulares se pueden recordar marcando la expresion entre <strong>(</strong> y <strong>)</strong> e invocarlo nuevamente con \ seguido de un solo dígito. Se pueden recordar hasta 9 patrones diferentes. Por ejemplo la siguiente expresión regular encuentra palíndromos de 5 letras como «radar»:
<code>\([a-z]\)\([a-z]\)[a-z]\2\1</code></p>

<p><strong>HOMEWORK</strong>
Decargue el [<a href="http://c3.itm.edu.co/bash/nombres.txt|archivo" target="_blank">http://c3.itm.edu.co/bash/nombres.txt|archivo</a>] retírele las líneas repetidas si exiten y realice:
* Busque los nombres que contengan «ana».
* Busque nombres que contengan ab en un lugar diferente del principio o del final.
* Busque palíndromos de 4 y 5 letras en el diccionario /usr/share/dict/spanish
* Busque los nombres que tengan tíldes.
* Busque nombres de menos de 4 letras que tengan diptongos.
* Busque los nombres que tengan alguna letra doble i.e. Vanessa.
* ¿Qué problemas podría presentar la expresión A.*B?</p>

<p>Existen otro tipo de expresiones regulares que no requieren  que los caracteres <code>( ) y { }</code> sean designados como <code>\(\) y \{\}</code>. A éstas se les llama expresiones regulares extendidas, pero no todos los lenguajes o programas las soportan.
En las expresiones regulares extendidas el caracter ? reemplaza cero o más caracteres que le preceden y el caracter + reemplaza uno o más.
La expresión entre los caracteres ( | ) reemplaza una escogencia de patrones, veamos mejor su uso con un par de ejemplos:</p>

<pre><code>$ grep '^(From|Subject): ' /var/spool/mail/$USER
$ grep -E '^(From|Subject): ' /var/spool/mail/$USER
$ echo &quot;expresion regular&quot; | egrep 'expresion[es]?( regular| irregular)?[es]?'
</code></pre>

<p>En esta tabla podrá consultar si la expresión se puede usar en la versión extendida o en la básica así como su función:
|Expresión|clase|función|
|&mdash;|&mdash;:|:&mdash;|
|.|Todas|Un solo caracter.|
|^|Todas|Principio de la línea.|
|$|Todas|Final de la línea.|
|[]|Todas|Conjunto de caracteres.|
|*|Todas|Cero o más duplicados.|
|&lt;|Básico|Principio de la palabra.|
|&gt;|Básico|Final de la palabra.|
|(..)|Básico|Recuerda un patrón.|
|\1..\9|Básico|invoca el patron recordado.|
|+|Extendido|Uno o más duplicados.|
|?|Extendido|Cero o más duplicados.|
|{M,N}|Extendido|M a N duplicados.|
|()|Extendido|Una u otra expresión.|</p>

<p><strong>EJERCICIOS</strong>
* Encuentre en el diccionario la palabras que tengan 2 o más consonantes consecutivas.
* Descargue el archivo [<a href="http://c3.itm.edu.co/bash/carros_perdidos.csv|carros_perdidos.csv" target="_blank">http://c3.itm.edu.co/bash/carros_perdidos.csv|carros_perdidos.csv</a>]
* Reporte las placas delos carros perdidos en Medellín y Bogotá en los años 2007, 2009 y 2011.
* Encuentre las ocurrencias de una palca inválida.
* Separe en diferentes archivos los carros por día de pico y placa.
* Separe en diferentes archivos los carros por marca.</p>

<h3 id="a-name-sed-a-sed"><a name="sed"></a>SED</h3>

<p><strong>sed</strong> (Short EDitor)  es un simple editor de flujos de texto que funciona por línea de comandos de la siguiente manera:</p>

<pre><code>$ echo &quot;foo&quot; | sed s/foo/bar
$ cat nombres.txt | sed s/ana/anita/
$ grep 'anita' nombres.txt
</code></pre>

<p>Gracias a la opción s, sed sustituye las ocurrencias de foo(ana) por bar(anita) haciendo una copia del flujo en stdout. Creemos un archivo y cambiamos hola por HOLA</p>

<pre><code>$ cat &gt; file.txt
hola mundo, hola
pirinhola hola
HoLa hola
$ cat file.txt | sed 's/hola/HOLA/'
</code></pre>

<p>Podemos observar que nada más las primeras ocurrencias de la palabra hola fueron cambiadas, el comando es sensible a las mayúsculas y es estricto con la ocurrencia, es decir, si la palabra existe en medio de otra, la cambia. La inclusión de comillas es necesaria cuando se usan caracteres especiales, pero es buena práctica utilizarlas siempre.
Es de notar que para encontrar un patrón a ser reemplazado por sed también se pueden usar expresiones regulares.</p>

<p><strong>HOMEWORK</strong>
* Discutamos las siguientes líneas:</p>

<pre><code>$ cat file.txt | sed '2s/hola/HOLA/'
$ cat file.txt | sed 's/hola/HOLA/I'
$ cat file.txt | sed 's/hola/HOLA/g'
$ cat file.txt | sed 's/,/\n/g'
$ echo abcd123 | sed 's/\([a-z]*\).*/\1/'
</code></pre>

<ul>
<li>Elimine la parte que va luego de la e del siguiente comando, incluyendo la e
<code>$ echo 1.4518e+25</code></li>
<li>Elimine los números de
<code>$ echo abc10002def</code></li>
<li>Elimine la primera columna y la primera fila del archivo patients.cvs y cambie los separadores «, » por espacios tabulados(\t).</li>
<li>Elimine las líneas que contengan números negativos del archivo att.dat</li>
<li>Cambie las ocurrencias de nombres con letras repetidas por una sola letra en el archivo nombres.txt.</li>
</ul>

<p><strong>ANSWERS</strong></p>

<pre><code>Solo aplica la sustitución en la segunda línea.
La I ignora si es mayúscula o minúscula.
La g cambia todas las ocurrencias en todas las líneas.
Cambia cada , por un salto de línea.
Quita las letras.
$ echo 1.4518e+25 | sed 's@e.*@@'
$ echo abc10002def | sed 's@[0-9]*@@g'
$ sed -e '1d' -e 's@gsp[0-9]\{1,3\},@@gI' -e 's@,@\t@g' patients.csv
$ sed '/-/d'
$ wc -l nombres.txt; sed 's@\([a-z]\)\1@\1@g' nombres.txt | sort | uniq | wc -l
</code></pre>

<p>Podemos realizar un script en sed que haga varias operaciones en secuencia sobre un archivo. Creemos el archivo patients.sed con las siguientes instrucciones</p>

<pre><code>1d
s@gsp[0-9]\{1,3\},@@gI
s/,/\t/g
</code></pre>

<p>Corremos este script con la instrucción</p>

<pre><code>$ sed -f patients.sed patients.csv
</code></pre>

<p>Vemos que resuelve uno de los ejercicios al quitar la primera línea, la primera columna y cambiar las comas por un espacio tabulado. Podemos también correr el script si invocamons en él el comando de la siguiente manera(10att.sed):</p>

<pre><code>#!/bin/sed -f
1,10s@\(.*\) \(.*\) \(.*\)@\1\t\2@pw att1-2.dat
</code></pre>

<p>Cambiamos los permisos de ejecución del script y luego lo ejecutamos</p>

<pre><code>$ chmod u+x 10att.sed
$ ./10att.sed -n att.dat
</code></pre>

<p>Este ejemplo usamos la opción -n para que no muestre en pantalla, la opción p para que imprima solamente lo modificado y w para que guarde en el archivo1-2.dat. Ejecute el ejemplo y identifique la expresión regular y la instrucción inicial (1,10s@).</p>

<p><strong>Ejercicios</strong>
* Cree scripts que a partir de un archivo con más de 3 columnas se obtengan 3 archivos:
    * Con las columnas 3 y 2, en ese orden, separadas por un espacio tabulado.
    * Con los números negativos de las columnas 2 y 3, eliminando la fila entera si lo encuentra.
    * Con los 100 primeros datos de las columnas 3, 1 y 2 separados por ;.</p>

<h3 id="a-name-awk-a-awk"><a name="awk"></a>AWK</h3>

<p><strong>AWK</strong> es un lenguaje de programación diseñado principalmente para la búsqueda y el procesamiento de texto. Como todos los lenguajes de programación tiene variables e instrucciones de control del flujo, como condicionales y bucles, AWK procesa cada línea de un archivo buscando patrones y realiza allí las acciones. Su sintaxis es:</p>

<pre><code>$ awk '/patrón1/ {acciones}; /patrón2/ {acciones}' archivo
</code></pre>

<p>Los patrones son expresiones regulares y recordemos que las comillas simples son para evitar que el shell no interprete los caracteres especiales.
Descarguemos el archivo [<a href="http://c3.itm.edu.co/bash/people.txt|people.txt" target="_blank">http://c3.itm.edu.co/bash/people.txt|people.txt</a>] y realicemos los siguientes ejemplos:</p>

<pre><code>$ awk '{print;}' people.txt
$ awk '/Sagan/' people.txt
$ awk '/Sagan/;/Asimov/' people.txt
</code></pre>

<p>Vemos que la acción «print» muestra(imrpime) todo el archivo y el patrón «Sagan» muestra solamente las líneas que contienen duicho patrón. Podemos también incluir varias operaciones para cada patrón:</p>

<pre><code>$ awk -F'[&amp;,;-]' '/Sagan/{print $2 $1};/Asimov/{print $2 $1}' people.txt
</code></pre>

<p>La opción -F nos permite indicarle a awk cuales son los caracteres que nos delimitarán los campos que son llamados por las variables $1 y $2 en este caso. El comando print también puede mostrar caracteres para construir expresiones como</p>

<pre><code>$ awk -F'[&amp;,;-]' '/Sagan/{print $2&quot; &quot; $1&quot; fue un gran &quot;$3&quot; y &quot;$4};/Asimov/{print &quot;Además de &quot;$3 &quot;, &quot;$2&quot; &quot; $1 &quot; era también&quot;$4}' people.txt
$ awk -F'[&amp;,;-]' '/Sagan/{printf &quot;%s %s fue un gran %s y %s \n&quot;,$2,$1,$3,$4};/Asimov/{printf &quot;Además de %s, %s %s era también %s\n&quot;,$3,$2,$1,$4}' people.txt
</code></pre>

<p>El comando printf a diferencia de print nos permite de manera más cómoda darle formato a la expresión a mostrar, en este caso usamos %s para imprimir cadenas de caracteres(strings), %d nos permitirá imprimir enteros y %f reales.
Vemos tambień que una instrucción con awk puede volverse tan compleja como ilegible, por ejemplo:</p>

<pre><code>$ awk -F'[;,-]' '{printf &quot;%s %s (%s)&quot;,$2,$1,$3;if(NF &gt; 6){age=$7-$4;printf&quot; murió en %d, a los %d años\n&quot;,$7,age}else{printf&quot; aún vive\n&quot;}}' people.txt
</code></pre>

<p>Por claridad y comodidad construimos un script llamado people.awk:</p>

<pre><code>BEGIN{FS=&quot;[;,-]&quot;} {
  $2 = substr($2,2) #Quita el espacio en blanco del nombre
  printf &quot;%s %s (%s) &quot;, $2, $1, $3
  if( NF &lt; 6 ) {
    edad = $7 -$4
    printf &quot;Murió en %d, a los %d años&quot;, $7, edad
  }
  else {
    printf &quot;Nació en %d y aún vive&quot;, $4
  }
}
</code></pre>

<p>En este script vemos que la opción -F se convierte en una acción de la instrucción BEGIN -FS significa Field Separator. Entre las llaves después de BEGIN van instrucciones que se ejecutarán antes de que awk comience a procesar el archivo de entrada; allí podemos inicializar variables, los separadores de campo, imprimir mensajes de inicio, etc.
<strong>substr</strong> toma un substring, i.e. una cadena de caracteres más corta tomada desde el segundo caracter de la variable 2.
La condición del <strong>if</strong> se cumple si el número de campos(<strong>NF</strong>) es mayor a 6, es decir, si la persona tiene fecha de muerte; calculamos la edad a la que murió tomando la diferencia. Si no ha muerto imrpimimos un mensaje diferente.</p>

<p>También podemos hacer ciclos en awk.</p>

<pre><code>BEGIN{
  a=1
  b=1
  while(++x&lt;=10){
    print a
    t=a
    a=a+b
    b=t
  }
  exit
}
</code></pre>

<p>También podemos definir funciones en awk:</p>

<pre><code>BEGIN{}
  function mod(a,b)
  {
    return (a&gt;=0) ? a%b : a%b+b
  }
  {
    a=mod($1,$2)
  }
END{print a}
</code></pre>

<p>La función mod returna a%b si a es positivo y a%b+b de otro modo. Esto permite definir correctamente la operación módulo para incluir números negativos.</p>

<p><strong>HOMEWORK</strong>
*Descargue el archivo [<a href="http://c3.itm.edu.co/bash/equipos.txt|equipos.txt" target="_blank">http://c3.itm.edu.co/bash/equipos.txt|equipos.txt</a>] y escriba un script de awk que:
**Calcule el promedio para cada persona
**Calcle el promedio por cada examen
**Calcule el promedio por cada equipo
Debe obtener un resultado como el siguiente</p>

<pre><code>Nombre       Promedio
------       --------
Astrid       14.67
Ana María    13.00
Luisa        15.00
Camilo       13.33
Jairo        19.50
Rubén        15.67
Andrés       13.00
Luis         15.00
------------------
Promedio del examen 1 : 5.00
promedio del examen 2 : 15.75
promedio del examen 3 : 22.12
-------------------
Promedio del equpo rojo: 16.12
promedio del equipo verde: 14.44
Promedio del equipo azul: 13.17
</code></pre>

<ul>
<li>Haga una función recursiva que invierta las palabras de un texto dado.</li>
<li>Decargue el archivo [http.//c3.itm.edu.co/bash/distancias.dat|distancias.dat] el cual es una lista de coordenadas 2D. Calcule la distancia entre las 2 posiciones en cada línea.</li>
<li>En una sola línea del comando awk, encuentre el máximo de cada columna del archivo att.dat.</li>
</ul>

<p><strong>ANSWERS</strong></p>

<pre><code>$ cat rev.awk
BEGIN{}
function rev(str, start)
{
    #note que no se necesitan los corchetes, también co una indentación es suficiente
    if (start == 0)
	    return &quot;&quot;
	#Retorna una cadena de caracteres con el último caracter seguida de una nueva
	#instancia de la función
	return (substr(str, start, 1) rev(str, start - 1))
}
{
    print rev($0,length($0))
}
$ echo &quot;dabale arroz a la zorra el abad&quot; | awk -f rev.awk
</code></pre>

<pre><code>$ sed 's/e[+-].\{1,2\}//g' distancias.dat | awk '{print sqrt(($4-$2)^2+($3-$1)^2)}'
$awk 'BEGIN{a=-1000;b=-1000;c=-1000}{if($1&gt;a) a=$1;if($2&gt;b) b=$2;if($3&gt;c) c=$3} END{printf &quot;max of each colum %f %f %f\n&quot;,a,b,c}' att.dat
</code></pre>

<p>Este último queda mejor en un archivo, max.awk:</p>

<pre><code>$cat max.awk
BEGIN{
  a=-1000
  b=-1000
  c=-1000
}
{
  if($1&gt;a) a=$1
  if($2&gt;b) b=$2
  if($3&gt;c) c=$3
}
END{printf &quot;max of each colum %f %f %f\n&quot;,a,b,c}
$ awk -f max.awk att.dat
</code></pre>

<h2 id="bash-scripting">BaSH scripting</h2>

<h3 id="a-name-scripting-a-scripting"><a name="scripting"></a>Scripting</h3>

<p>Un script es un archivo que contiene una serie de comandos a ser ejecutados por el shell. Éste puede interpretar dicho archivo así como cada entrada en la línea de comandos.
Para crear un script abrimos un editor de texto (nano,pico,vim,emacs,gedit,kate) y en él podemos escribir cualesquier comandos vistos hasta el momento que serán ejecutados en el orde de aparición en el archivo. Veamos un ejemplo:</p>

<pre><code>$ cat script.bash
mkdir prueba
touch prueba/testfile
ls
rm prueba/ 2&gt; rm.log
cat rm.log
$ bash script
</code></pre>

<p>Creamos el archivo script. Al finalizar podemos ejecutar el script invocando al shell, en este caso bash.</p>

<p>Existen otro tipo de programas(lenguajes o interpretes) de scripting como python o R, así como otros shells coo ksh, csh, zsh o sh, cada uno de ellos con características diferentes. sh fue por muchos años el que venía por defecto con la instalación de linux pero éste ahora instala BaSH que es uan versión mejorada, probemos el siguiente comando:</p>

<pre><code>$ echo &quot;whatis {sed, awk, bc}&quot; | sh
$ echo &quot;whatis {sed, awk, bc}&quot; | bash
</code></pre>

<p>Notemos que sh no entiende las extensiónes que vimos en sesiones anteriores mientras qeu bash sí.
los archivos de scripting se suelen nombrar con la extensión del programa que los debe ejecutar, es decir, tomaremos la costumbre de nombrar los archivos que correran con bash, script.bash, los de sed, script.sed y los de awk, script.awk.</p>

<p>Podemos hacer estos scripts ejecutables agregando al principio del archivo una línea que le indica al sistema cuál es el programa que va a interpretar dicho script:</p>

<pre><code>#!/ruta/al/interprete
</code></pre>

<p>Este caso el interprete será bash, o bien puede ser awk, python, etc. A continuación dedemos cambiar los permisos del archivo pues por defecto no tiene la posibilidad de ejecutarse, recordemos:</p>

<pre><code>$ chmod +x script.bash
</code></pre>

<p>Para ejecutarlos damos la ruta completa al script, recordemos las opciones:</p>

<pre><code>$ /home/usuario/carpeta/script.bash
$ ./script.bash
$ $PWD/script.bash
</code></pre>

<p><strong>HOMEWORK</strong>
* Haga que los archivos .awk sen ejecutables.
* Cree un script que liste los usuarios y su carpeta de home tomando los datos del archivo /etc/passwd
* Haga que los archivos .sed sean ejecutables.</p>

<p>Recordemos la asignación y el uso de las variables con el siguiente ejemplo, creamos un archivo con el nombre variables.bash</p>

<pre><code>var1=a var2=b
string1=&quot;dos palabras&quot;
string2=&quot;$string1 y otras 2&quot;
comando=$(seq 1 2 20)
operacion=$((7%5))

echo $var1 $var2
echo $string1
echo $string2
echo $comando
echo $operacion
</code></pre>

<p>En el ejemplo podemos notar que se pueden hacer varias asignaciones en la misma línea, las cadenas de caracteres con espacios se deben indicar con comillas y podemos usar el valor de una variable para crear otra.</p>

<p>Realicemos los siguientes comandos:</p>

<pre><code>$ file=&quot;texto&quot;
$ touch $file
$ ls
$ mv $file $file1
</code></pre>

<p>No es posible renombrar el archivo &ldquo;texto&rdquo; a &ldquo;texto1&rdquo; pues la variable file1 no existe:</p>

<pre><code>$ mv $file ${file}1
</code></pre>

<p>BaSH así como AWK también tiene funciones, es decir, fragmentod de código con nombre que se pueden invocar posteriormente. Su sintaxis es igual:</p>

<pre><code>#!/bin/bash 
function wait {
  echo &quot;waiting...&quot;
  sleep 2
}

echo &quot;La terminal entra en modo de espera&quot;
wait
echo &quot;Bienvenido nuevamente&quot;
</code></pre>

<p>Las funciones en BaSH también pueden tener argumentos y &ldquo;retornar&rdquo; valores:</p>

<pre><code>#!/bin/bash
function suma() {
  resultado=$(($1+$2))
}

suma 3 2
echo &quot;la suma entre 3 y 2 es&quot; $resultado
</code></pre>

<p>Vemos que la variable resultado definida en la función es una variable global, es decir, podemos acceder a ella desde cualquier parte del script. Podemos también definir variables locales, esto es, que solo existen dentro de la función:</p>

<pre><code>#! /bin/bash
var=0
function func1 {
  local var
  var=1
  echo &quot;la variable var en func1 es: $var&quot;
}
function func2 {
  local var
  echo &quot;la variable en func 2: $var&quot;
}

echo &quot;var es: $var&quot;
func1
func2
echo &quot;var sigue siendo $var&quot;
</code></pre>

<p>Observamos que la variable var a pesar de ser redefinida con el mismo nombre en cada función, esta redefinición solo tiene efecto dentro de la susodicha.
Podemos también pedirle al usuario que ingrese datos por stdin:</p>

<pre><code>#!/usr/bin/env bash
echo &quot;Ingrese su nombre&quot;
read input
echo &quot;Bienvenido $input&quot;
</code></pre>

<p><strong>HOMEWORK</strong>
* Discuta la siguiente línea</p>

<pre><code>$ a=asd;b=1;a+=$b
</code></pre>

<p>*Imprima la variable $0 en un script de BaSH
*Cree un script que imprima $1 y $2 y ejecute</p>

<pre><code>$ ./script.bash hola mundo
</code></pre>

<ul>
<li>Cree una función que duerma la cantidad de segundos dada como argumento.</li>
<li>Modifique el script anterior para que el tiempo sea ingresado como argumento por línea de comandos.</li>
<li>Cree un script que pida el usuario y revise si se encuentra en el sistema, dado el caso que reporte la ruta al home, cuantos carpetas tiene y cuantos archivos.</li>
<li>El comando ps aux entrega varias columnas: usuario pid %cpu %mem vsz rss tty stat start time command. Cree un script que dado un usuario imprima: las tareas que está corriendo(solo el nombre, no al ruta completa); el PID; el uso de procesador y memoria; y el tiempo que lleva corriendo, solo si cumple las condiciones:

<ul>
<li>Memoria usada != 0.0</li>
<li>%CPU usada != 0.0</li>
</ul></li>
</ul>

<p><strong>ANSWERS</strong><br />
* La secuencia de comandos a=asd;b=1;a+=$b toma los valores de las variables como cadens de caracteres y los concatena.<br />
* Imprime el nombre del script.<br />
* Imprime &ldquo;Hola Mundo&rdquo; pues $1 y $2 son el primer y segundo argumento del script respectivamente.<br />
* Una reescritura del comando sleep con algunos mensajes wait.bash</p>

<pre><code>#!/bin/bash
function wait() {
    echo &quot;Esperando...&quot;
    sleep $1
}

echo &quot;La Terminal entra en modo de espera&quot;
wait 3
echo &quot;Bienvenido Nuevamente&quot;
</code></pre>

<ul>
<li>Como $1 es el primer argumento del script así como de la función, reescribimos:<br /></li>
</ul>

<pre><code>#!/bin/bash
function wait() {
    echo &quot;Esperando...&quot;
    sleep $1
}

echo &quot;La Terminal entra en modo de espera&quot;
wait $1
echo &quot;Bienvenido Nuevamente&quot;
</code></pre>

<ul>
<li>El script debe ser algo similar a este:<br /></li>
</ul>

<pre><code>#!/bin/bash

folders=$(ls -lr /home/$1 | grep -c '^d')
files=$(ls -lr /home/$1 | grep -v -c '^d')

echo &quot;El usuario $1 tiene $folders carpetas y $files archivos.&quot;
</code></pre>

<h3 id="a-name-stream-a-loops-and-conditionals"><a name="stream"></a>Loops and Conditionals</h3>

<p>Así como en awk y en todos los lenguajes, deben existir herramientas de control de flujo: condicionales y bucles.
Los bucles nos permiten realizar un conjunto de tareas varias veces, veamos un ejemplo básico:</p>

<pre><code>#!/bin/bash
contador=0
for i in $(ls)
do
contador=$((contador+1))
echo $i
done
echo &quot;En total hay $contador archivos&quot;
</code></pre>

<p>Este script cuenta los archivos en $PWD luego de listarlos.
La variable i toma uno por uno los valores del comando ls en este caso, que son impresos con echo. Notemos que el contador es una operación aritmética que tiene una sintaxis particular, las variables pueden ir sin el caracter de moneda.
La instrucción que se repetirá a través del <strong>for</strong> debe ir entre las palabras claves, do y done, al igual que en el caso del bucle <strong>while</strong>.</p>

<pre><code>#!/bin/bash
x=1
while [ $x -le 5 ]
do
  echo &quot;$x todavia es menor que 5&quot;
  x=$(( $x + 1 ))
done
</code></pre>

<p>While realiza las operaciones internas mientras la condición sea válida.
El comando <strong>until</strong> es similar pero se detiene cuando la condición lógica se cumple:</p>

<pre><code>#!/bin/bash
x=1
until [ $x -ge 5 ]
do
  echo &quot;$x todavia es menor que 5&quot;
  x=$(( $x + 1 ))
done
</code></pre>

<p><strong>HOMEWORK</strong><br />
* Cree un script que duerma un segundo e imprima un punto por cada archivo en $PWD y finalmente imprima el espacio en disco que ocupa la suma de los archivos.
* Modifique el script anterior para que la ruta sea entrada como argumento por línea de comandos.</p>

<p>Otro mencanismo de control de flujo es condicional <strong>if</strong>, su sintaxis es:</p>

<pre><code>if comando
then
    comando
else
    otro comando
fi
</code></pre>

<p>Como <strong>if</strong> evalua una condición, no es de mucho sentido que su argumento sea un comando. Los comandos siempre devuelven un estado (exit status) verdadero si el comando se realizó con éxito y falso de otro modo, vemos un ejemplo:</p>

<pre><code>$ ls asd; echo $?
$ ls ~; echo $?
$ false; echo $?
$ true; echo $?
$ [ 4 = 1 ] ; echo $?
$ [ 1 = 1 ] ; echo $?
</code></pre>

<p>Vemos que un comando realizado exitosamente nos retorna un 0 (que podemos ver en la variable $?) y un valor de retorno diferente a 0 significa que el comando tuvo un error.
Vemos allí también la forma de evaluar expresiones lógicas y el significado de los comandos <strong>true</strong> y <strong>false</strong>.
Consideremos el script:</p>

<pre><code>#!/bin/bash

FILE = $1
if [ -e &quot;$FILE&quot; ]; then
  if [ -f &quot;$FILE&quot; ]; then
    echo &quot;$FILE es un archivo regular&quot;
  fi
  if [ -d &quot;$FILE&quot; ]; then
    echo &quot;$FILE es un directorio.&quot;
  fi
  if [ -r &quot;$FILE&quot; ]; then
    echo &quot;$FILE es legible.&quot;
  fi
  if [ -w &quot;$FILE&quot; ]; then
    echo &quot;$FILE es escribible.&quot;
  fi
  if [ -x &quot;$FILE&quot; ]; then
    echo &quot;$FILE es ejecutable o navegable.&quot;
  fi
else
  echo &quot;$FILE does not exist&quot;
  exit 1
fi
exit
</code></pre>

<p>Podemos evaluar el status de archivos, las expresiones se encuentran en la siguiente tabla:</p>

<table>
<thead>
<tr>
<th align="left"><strong>Expresión</strong></th>
<th align="left"><strong>Verdadera si</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">file1 -nt file2</td>
<td align="left">file1 es más nuevo que file2</td>
</tr>

<tr>
<td align="left">file1 -ot file2</td>
<td align="left">file1 es más nuevo que file2</td>
</tr>

<tr>
<td align="left">-b file</td>
<td align="left">file existe y es un dispositivo</td>
</tr>

<tr>
<td align="left">-d file</td>
<td align="left">file existe y es un directorio</td>
</tr>

<tr>
<td align="left">-e file</td>
<td align="left">file existe</td>
</tr>

<tr>
<td align="left">-f file</td>
<td align="left">file existe y es un archivo regular</td>
</tr>

<tr>
<td align="left">-L file</td>
<td align="left">file existe y es un link simbólico</td>
</tr>

<tr>
<td align="left">-O file</td>
<td align="left">file existe y el usuario es su dueño</td>
</tr>

<tr>
<td align="left">-r file</td>
<td align="left">file existe y es legible</td>
</tr>

<tr>
<td align="left">-r file</td>
<td align="left">file existe y tiene un tamaño maor a cero</td>
</tr>

<tr>
<td align="left">-w file</td>
<td align="left">file existe y es escribible</td>
</tr>

<tr>
<td align="left">-x file</td>
<td align="left">file existe y es ejecutable</td>
</tr>
</tbody>
</table>

<p>También podemos hacer comparaciones de cadenas de caracteres y enteros:</p>

<table>
<thead>
<tr>
<th align="left"><strong>Expresión</strong></th>
<th align="left"><strong>Verdadera si</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">string</td>
<td align="left">No es null</td>
</tr>

<tr>
<td align="left">-n string</td>
<td align="left">La longitud es diferente de cero</td>
</tr>

<tr>
<td align="left">-z string</td>
<td align="left">La longitud es igual a cero</td>
</tr>

<tr>
<td align="left">string1 == string 2</td>
<td align="left">Son iguales</td>
</tr>

<tr>
<td align="left">string1 != string2</td>
<td align="left">Son diferentes</td>
</tr>

<tr>
<td align="left">string1 &gt; string2</td>
<td align="left">string1 organiza primero que string2</td>
</tr>

<tr>
<td align="left">string2 &lt; string2</td>
<td align="left">string2 organiza primero que string1</td>
</tr>

<tr>
<td align="left">int1 -eq int2</td>
<td align="left">Iguales</td>
</tr>

<tr>
<td align="left">int1 -ne int2</td>
<td align="left">Diferentes</td>
</tr>

<tr>
<td align="left">int1 -le int2</td>
<td align="left">int1 menor o igual a int2</td>
</tr>

<tr>
<td align="left">int1 -lt int2</td>
<td align="left">int1 menor que int2</td>
</tr>

<tr>
<td align="left">int1 -ge int2</td>
<td align="left">int1 mayor o igual a int2</td>
</tr>

<tr>
<td align="left">int1 -gt int2</td>
<td align="left">int1 mayor que int2</td>
</tr>
</tbody>
</table>

<p>una versión actual de bash permite el uso de dobles corchetes en vez de simples para hacer una operación lógica, estos adicionalmente permiten la comparación de una cádena de caracteres con una expresión regular a través del operador =~.<br />
El siguiente código revisa si el dato entrado es un número entre otras cosas:</p>

<pre><code>#!/bin/bash
if[[ &quot;$1&quot; =~ ^-?[0-9]+$ ]]
then
  echo Ha ingresado un número&quot;
else
  echo &quot;Por favor ingrese un número&quot; &gt;&amp;2
  exit 1
fi
</code></pre>

<p>También podemos usar dobles paréntesis para evaluar operaciones lógicas con números de una manera más sencilla que con las expresiones necesarias en los corchetes.</p>

<pre><code>$ num=12;if((num&gt;=10));then echo &quot;mayor que 10&quot;;fi
</code></pre>

<p>Si queremos crear expresiones lógica más complejas podemos usar las compuertas AND, OR y NOT que tienen una representación diferente si usamos los corchetes simples o dobles.</p>

<table>
<thead>
<tr>
<th><strong>Compuerta</strong></th>
<th align="center"><strong>[]</strong></th>
<th align="left"><strong>[[]] o (())</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td>AND</td>
<td align="center">-a</td>
<td align="left">&amp;&amp;</td>
</tr>

<tr>
<td>OR</td>
<td align="center">-o</td>
<td align="left">`</td>
</tr>

<tr>
<td>NOT</td>
<td align="center">!</td>
<td align="left">!</td>
</tr>
</tbody>
</table>

<p>El siguiente script mira si el número está entre 1 y 10:</p>

<pre><code>#!/bin/bash
if [[ $1 -ge 1 &amp;&amp; $1 -le 10 ]]
then
  echo &quot;el número se encuentra entre 1 y 10&quot;
else
  echo &quot;Ingrese un número válido&quot; &gt;&amp;2
  exit 1
fi
</code></pre>

<p><strong>HOMEWORK</strong></p>

<ul>
<li>Cree un script que cuente 10 segundo mientras ud se cuenta las pulsaciones, que luego pida ingresar ese número y calcule los ppm(pulsaciones por minuto).</li>
<li>Edite la solución al ejercicio de los usuarios de la sesión anterior para que realice manejo de error.</li>
<li>Con la variable de entorno RANDOM cree un script que genere un archivo de datos con 3 columnas de estos números que no sobre pase un tamaño (espacio en disco) dado por el usuario.</li>
<li>Con un script reporte las carpetas del home(o de otra carpeta) que sobrepasen en espacio un umbral dado por línea de comandos sugiriendo borrarlas, si el usuario así lo desea, bórrelas.</li>
<li>Genere un mensaje de uso (-h) para los scripts anteriores.</li>
</ul>

<p><strong>ANSWERS</strong></p>

<ul>
<li>Lo puede realizar sencillamente en una sola línea de comandos:</li>
</ul>

<pre><code>$ sleep 10;echo &quot;ingrese conteo&quot;;read conteo;echo $((conteo*6))
</code></pre>

<p>O bien en un script para que de mejor información:</p>

<pre><code>echo presione &quot;Enter para iniciar conteo&quot;
read intro
for i in $(seq 1 1 10)
do
sleep 1
echo $i
done
echo &quot;Ingrese conteo&quot;
read conteo
echo &quot;Sus pulsaciones por minuto son: $((conteo*6))&quot;
</code></pre>

<ul>
<li>El ejercicio pide dar un reporte de la cantidad de los archivos y las carpetas en el home del usuario, para asegurar que el usuario sea válido basta con agregar una condición:</li>
</ul>

<pre><code>#!/bin/bash
if [ -d /home/$1 ]
then
  folders=$(ls -lr /home/$1 | grep -c '^d')
  files=$(ls -lr /home/$1 | grep -v -c '^d')
  echo &quot;El usuario $1 tiene $folders carpetas y $files archivos.&quot;
else
  echo &quot;El usuario no existe.&quot;
fi
</code></pre>

<ul>
<li>Primero miramos si el archivo existe y lo borramos para no hacerlo más grande, luego hacemos un blucle que termina cuando el tamaño del archivo &ldquo;size&rdquo; es mayor que el tamaño entrado por el usuario a través de línea de comandos.</li>
</ul>

<pre><code>#!/bin/bash

max_size=$1
size=0

if [ -e 3Drandom.dat ]
then
  rm -rf 3Drandom.dat
fi

while (( $size &lt;= $max_size ))
do
  echo $RANDOM $RANDOM $RANDOM &gt;&gt; 3Drandom.dat
  size=$(ls -l 3Drandom.dat | awk '{print $5}')
  echo $size $max_size
done
</code></pre>

<h3 id="a-name-files-a-file-io"><a name="files"></a>FIle IO</h3>

<p>Sabemos que a través de una redirección podemos escribir en archivos, pero frecuentemente necesitamos también leer datos de estos. Podríamos usar scripts en awk pero no siempre es tan ventajoso. Veamos unos ejemplos de como hacerlo en bash leyendo el archivo <a href="thttp://c3.itm.edu.co/bash/lineas.txt" target="_blank">lineas.tx</a>:<br />
Lectura con cat</p>

<pre><code>#!/bin/bash
FILE=lineas.txt
conteo=1
cat $FILE | while read line; do
  echo &quot;Línea # $conteo: $line&quot;
  ((conteo++))
done
echo &quot;El número total de líneas en $FILE es $conteo&quot;
</code></pre>

<p>¿Qué problemas presenta esta forma de leer?</p>

<p>El siguiente código es el más intuitivo pero también la peor forma de leer un archivo:</p>

<pre><code>FILE=lineas.txt
for line in $(cat $FILE);do
  echo $fileline 
done
</code></pre>

<p>La forma correcta de leer un archivo es:</p>

<pre><code>conteo=1
FILE=lineas.txt
while read line;do
  echo &quot;Linea # $conteo: $line&quot;
  ((conteo++))
done &lt; $FILE
echo &quot;El número total de líneas en $FILE es $conteo&quot;
</code></pre>

<p><strong>HOMEWORK</strong></p>

<ul>
<li>Descargue los archivos <a href="http://c3.itm.edu.co/bash/participantes.lst" target="_blank">participantes.lst</a> y <a href="http://c3.itm.edu.co/bash/certificado_Gerardo_Gutierrez.svg" target="_blank">certificado.svg</a>. Identifique el archivo svg y genere un certificado en este formato para cada participante en un archivo diferente.</li>
</ul>

<h3 id="a-name-bc-a-bc"><a name="bc"></a>bc</h3>

<p>Ya que bash solo procesa enteros, para realizar tareas numéricas encesitamos de una herramienta diferente que nos permita la utilización de reales.
bc es un lenguaje de programación que soporta precisión arbitraria y nos permite realizar scripts o usarlo de manera interactiva. Soporta las operaciones básicas:</p>

<pre><code>$ echo &quot;12*3&quot; | bc
$ echo &quot;1.013/115&quot; | bc
$ echo &quot;6^6^6&quot; | bc
$ echo &quot;(6^6)^6&quot; | bc
</code></pre>

<p>Para usar funciones como las trigonométricas o Bessel tenemos que invocar la librería matemática, veams un ejemplo:</p>

<pre><code>$ echo &quot;e(1)&quot; | bc -l
$ echo &quot;j(0,10)&quot; | bc -l
$ echo &quot;4*a(1)&quot; | bc -l
</code></pre>

<p>Podemos definir la precisión necesaria de la siguiente manera</p>

<pre><code>$ echo &quot;scale=30;sqrt(2)&quot;| bc
</code></pre>

<p><strong>HOMEWORK</strong></p>

<ul>
<li>Obtenga el tiempo que toma calcular pi con 500 cifras decimales.<br /></li>
<li>Genere los números de exp(x) entre 0 y 2 y agregueles ruido con distribución normal. i.e. sume un número aleatorio con cualquier desviación estandard.</li>
</ul>

<h3 id="a-name-arrays-a-arrays"><a name="arrays"></a>Arrays</h3>

<p>Los arreglos (arrays) son variables que guardan más de un valor a la vez. En BaSH se limitan a una sola dimensión y son declaradas durante su uso, miremos los ejemplos:</p>

<pre><code>$ array[1]=hola;echo ${array[1]};
$ dias=(lun mar mie jue vie sab dom); echo $(dias[3])
$ echo ${dias[*]}

</code></pre>

<p>Vemos que también se pueden crear varios valores a la vez durante la asignación y como acceder a dichos valores. Veamos entonces un ejemplo de como acceder de a un elemento del arreglo a la vez:</p>

<pre><code>$ animales=(&quot;un perro&quot; &quot;un gato&quot; &quot;una tortuga&quot;)
$ for i in ${animales[*]}; do echo $i;done
$ for i in ${animales[@]}; do echo $i;done
$ for i in &quot;${animales[*]}&quot;; do echo $i;done
$ for i in &quot;${animales[@]}&quot;; do echo $i;done
</code></pre>

<p>Vemos que podemos acceder a cada elemento del arreglo con <code>*</code> o con @ y su comportamiento es igual hasta que se encomillan. Con <code>*</code> obtenemos una sola palabra con los contenidos del arreglo, en cambio con @ obtenemos (en neutro caso) 3 palabras, cada una con el contenido de cada elemento del arreglo.</p>

<p>Discutamos las siguientes operaciones:</p>

<pre><code>$ echo ${#animales[@]}
$ echo ${#animales[0]}
$ animales+=(&quot;un caballo&quot; &quot;un cuy&quot;)
$ for i in &quot;${animales[@]}&quot;; do echo $i; done | sort
$ unset animales
</code></pre>

<h3 id="a-name-torque-a-bash-qsub"><a name="torque"></a>BaSH &amp; qsub</h3>

<p><strong>TORQUE Resource manager</strong> es un software que permite «agendar» tareas computacionales,i.e.
«tareas batch». Provee control sobre estas tareas y los recursos computacinoales de sistemas distribuidos. Posee los siguientes componentes:<br />
<strong>Servidor:</strong> En este caso se llama &ldquo;pbs_server&rdquo;. Permite operaciones básicas como crear, modificar, borrar y ejecutar un trabajo.<br />
<strong>Ejecutor:</strong> Es un demonio, llamado en nuestro caso &ldquo;pbs_mom&rdquo;, que pone el comando en ejecución cuando recibe una copia del trabajo de el server.<br />
<strong>Agendador:</strong> Otro demonio que tiene las políticas para decidir que trabajo se ejecuta, donde y cuando. Usamos el agendador MAUI el cual se puede comunicar con varios MOMs para comunicar al servidor el estado de los recursos y para conocer del servidor el estado de los trabajos a ejecutar.</p>

<p>El flujo de trabajo de torque es como se ilustra en el diagrama:
<img src="../../images/torque-wf.png" alt="torque" /></p>

<p><strong>Hola Torque</strong></p>

<p>Usted puede solicitar a TORQUE el estado de un nodo con el comando &ldquo;pbsnodes&rdquo; o de todos los nodos con &ldquo;pbsnodes -a&rdquo;, con los cuales debe obtener una salida como esta para cada nodo en el sistema:</p>

<pre><code>wn1
     state = free
     np = 32
     ntype = cluster
     status = rectime=1376977699,varattr=,jobs=,state=free,netload=28936987148,gres=,
              loadave=1.04,ncpus=32,physmem=57801956kb,availmem=100795756kb,
              totmem=106629856kb,idletime=1149356,nusers=1,nsessions=2,sessions=2996358788,
              uname=Linux gfif-wn1 3.2.0-4-amd64 #1 SMP Debian 3.2.41-2 x86_64,opsys=linux
</code></pre>

<p>«free» significa que el nodo está en capacidad de correr tareas, «np» es el número de procesadores.</p>

<p><strong>Enviar un trabajo</strong></p>

<p>Para enviar un trabajo o tarea al sistema TORQUE es necesario crear un script de shell (puede ser bash, sh, ksh, etc) con directivas especiales a modo de comentario&hellip;</p>

<pre><code>#! /bin/bash
#PBS -N prueba
#PBS -o prueba.out
#PBS -e prueba.err
#PBS -l walltime=00:01:00

date
hostname
</code></pre>

<p>Archivo que hemos llamado prueba.bash para correrlo así</p>

<pre><code>$ qsub prueba.bash
</code></pre>

<p>¿Cómo espera usted que sea la salida de este trabajo?
Si está corriendo en múltiples máquinas ¿Dónde se espera encontrar el stdout?</p>

<p><strong>HOMEWORK</strong></p>

<ul>
<li>Cree un script en bash con instrucciones de torque que duerma 20 segundos y reporte el nombre del nodo en el que corrió y la cantidad de procesadores que éste tiene.</li>
</ul>

<p><strong>Monitorear el trabajo</strong></p>

<p>El comando &ldquo;qstat -a&rdquo; nos muestra el estado de los trabajos de todas las colas, obtenemos uua salida como esta</p>

<pre><code>Job ID               Username Queue    Jobname          SessID NDS   TSK Memory Time  S Time
-------------------- -------- -------- ---------------- ------ ----- --- ------ ----- - -----
1171.gfif.udea.e     gerardo  batch    prueba            21476     2   2    --  00:01 R   --
</code></pre>

<p>Algunos comandos de pbs para monitoreo y control son</p>

<p><strong>qstat -a</strong>: Verifica el estado de los trabajos, las colas y el servidor PBS.<br />
<strong>qstat -f</strong>: Obtiene toda la información del trabajo lanzado, como: Recursos pedidos, cola, fuente, destino, propietario, recursos límite, etc.<br />
<strong>qdel job.ID</strong>: Borra un trabajo.<br />
<strong>qhold job.ID</strong>: Pone un trabajo en estado de espera si se encuentra en cola.<br />
<strong>qrls job.ID</strong>: Saca a un trabajo del estado de espera.</p>

<p>Algunos comandos útiles de maui</p>

<p><strong>showq</strong>: Muestra una lista detallada de los trabajos lanzados.<br />
<strong>showbf</strong>: uestra los recursos libres.<br />
<strong>checkjob job.ID</strong>: muestra una descripción detallada del trabajo.<br />
<strong>showstart job.ID</strong>: Muestra el tiempo estimado de comienzo del trabajo.</p>

<p><strong>El script de PBS</strong><br />
Algunas opciones de PBS para el script son</p>

<table>
<thead>
<tr>
<th align="left">Opción</th>
<th align="left">Descripción</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">#PBS -N myJob</td>
<td align="left">Asigna el nombre a un trabajo</td>
</tr>

<tr>
<td align="left">#PBS -l nodes=4:ppn=2</td>
<td align="left">El número de nodos y procesos por nodo</td>
</tr>

<tr>
<td align="left">#PBS -q queuename</td>
<td align="left">Asigna la cola en al que su trabajo va a estar.</td>
</tr>

<tr>
<td align="left">#PBS -l walltime=01:00:00</td>
<td align="left">El tiempo de reloj «de pared» durante el cual su trabajo puede correr.</td>
</tr>

<tr>
<td align="left">#PBS -o mypath/my.out</td>
<td align="left">La dirección y el nombre del archivo para guardar el stdout.</td>
</tr>

<tr>
<td align="left">#PBS -e mypath/my.err</td>
<td align="left">La dirección y el nombre del archivo para guardar el stderr.</td>
</tr>

<tr>
<td align="left">#PBS -j oe</td>
<td align="left">Une el stdout con el stderr.</td>
</tr>

<tr>
<td align="left">#PBS -M user@mail</td>
<td align="left">email del usuario al cual enviar reportes.</td>
</tr>

<tr>
<td align="left">#PBS -m b</td>
<td align="left">Envia un email cuando el trabajo comienza.</td>
</tr>

<tr>
<td align="left">#PBS -m e</td>
<td align="left">Envia un email cuando el trabajo termina.</td>
</tr>

<tr>
<td align="left">#PBS -m a</td>
<td align="left">Envia un email cuando el trabajo aborta por un error.</td>
</tr>

<tr>
<td align="left">#PBS -V</td>
<td align="left">Exporta todas las variables de entorno al trabajo.</td>
</tr>
</tbody>
</table>

<p>La opción -l pasa una lista de argumentos a qsub que indican la cantidad de recusros reservados para el conjunto de tareas, por ejemplo:</p>

<pre><code>#PBS -l mem=1gb,nodes=1:ppn=1,walltime=1:00:00
#PBS -l mem=1gb,nodes=sas+1:ppn=1,walltime=1:00:00
#PBS -l mem=32g,nodes=quadcore+4:ppn=8,walltime=1:00:00
#PBS -l pmem=1gb,nodes=quadcore+2:ppn=4,walltime=1:00:00
</code></pre>

<p>Algunas variables de entorno de PBS son<br />
PBS_O_HOME  La ruta al home de el que se corrió qsub<br />
PBS_O_WORKDIR  El directorio en el que se corrió qsub<br />
PBS_O_LOGNAME  El nombre de usuario que corrió qsub<br />
PBS_O_HOST  El nombre de la máquina en la que se corrió qsub<br />
PBS_O_QUEUE  La cola a la que el trabajo fue enviado<br />
PBS_JOBID  El identificador que asigna PBS al trabajo<br />
PBS_JOBNAME  El nombre del trabajo|<br />
PBS_NODEFILE  El archivo que contiene la lista de nodos para tareas en paralelo|</p>

<p><strong>Multiples trabajos</strong><br />
Si quisieramos realizar muchas tareas con un mismo script o con un mismo código podríamos hacer un script en bash que llame varias veces a qsub cambiando los parámetros necesarios. Para evitar esto, torque permite lanzar mucho procesos invocando una sola vez el comando qsub, esto se llama, arreglos de tareas.<br />
Para enviar arreglos de tareas usamos la opción #PBS -t en su script de bash conuna lista de números como argumento</p>

<pre><code>#PBS -t 0-5
#PBS -t 10-20,30,40
</code></pre>

<p><strong>HOMEWORK</strong></p>

<ul>
<li>Modifique el script anterior para que corra 10 veces y reporte las variables de entorno de pbs. Imprima también la variable PBS_ARRAYID.<br /></li>
<li>Modifique el script anterior para que cada trabajo corra en un nodo diferente.<br /></li>
<li>Descargue el archivo <a href="http://c3.itm.edu.co/bash/password.bash" target="_blank">password.bash</a>. Este programa recibe una contraseña por línea de comandos. Encuentre, usando el diccionario de linux y torque, el password de dicho programa.<br /></li>
<li>Descargue el archivo ejecutable <a href="http://c3.itm.edu.co/bash/integral" target="_blank">integral</a> que calcula la integral de cos²(x)/x² entre 2 y un número entrado por línea de comandos.
Tal integral debe converger a más o menos 0.273993, realice la siguiente prueba<br /></li>
</ul>

<pre><code>$ time ./integral 100 1 0
</code></pre>

<p>Veamos que el código recibe 3 argumentos, el primero es el límite superior de la integral, el segundo es el número de procesos en los que se va a dividir y el tercero es el procesador actual.
Con esto realice una trabajo de torque que haga la integral hasta 10⁵ en varios procesadores del clúster.</p>

<ul>
<li>Descarge el archivo comprimido <a href="zhttp://c3.itm.edu.co/bash/ejercicio-torque.tbz" target="_blank">ejercicio-torque.tbz</a>, decomprímalo y realice un script con torque que por cada archivo reemplace el hash con su equivalente en letras, quite los espacios y las líneas que quedan con números, luego con los archivos resultantes genere uno solo en el host.</li>
</ul>

					</div>
				</article>
                

			</div>
		</div>

		<center class="">
			<ul class="pagination">
                

			</ul>
		</center>


	</div>	

</main>

<footer id="footer">
	<div class="container">
		<div class="row">
			
			<div class="col-md-3 widget">
				<h3 class="widget-title">Contact</h3>
				<div class="widget-body">
					<p><br>
						<a href="mailto:ggutierg@gmail.com">ggutierg@gmail.com</a><br>
						<br>
						
					</p>
				</div>
			</div>
			

			
			<div class="col-md-3 widget">
				<h3 class="widget-title">Follow me</h3>
				<div class="widget-body">
					<p class="follow-me-icons">
                        
                            
                        
                            
                                <a href="https://twitter.com/muzzgo" target="_blank"><i class="fa fa-twitter-square fa-2"></i></a>
                            
                        
                            
                                <a href="https://www.instagram.com/muzzgash" target="_blank"><i class="fa fa-instagram fa-2"></i></a>
                            
                        
                            
                        
                            
                                <a href="https://www.linkedin.com/in/gerardo-guti%c3%a9rrez-b8695386" target="_blank"><i class="fa fa-linkedin-square fa-2"></i></a>
                            
                        
                            
                        
                            
                                <a href="https://github.com/muzgash" target="_blank"><i class="fa fa-github fa-2"></i></a>
                            
                        
                            
                        
					</p>
				</div>
			</div>
			

			

			

		</div> 
	</div>
</footer>

<footer id="underfooter">
	<div class="container">
		<div class="row">

			<div class="col-md-6 widget">
				<div class="widget-body">
					<p></p>
				</div>
			</div>

			<div class="col-md-6 widget">
				<div class="widget-body">
					<p class="text-right">
						Copyright &copy; , Gerardo Gutiérrez<br>
						Design: <a href="http://www.gettemplate.com" rel="designer">Initio by GetTemplate</a> - 
                        Powered by: <a href="https://gohugo.io/" rel="poweredby">Hugo</a>
                    </p>
				</div>
			</div>

		</div> 
	</div>
</footer>




<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<script src="http://gerardogutierrez.co/en/js/template.js"></script>
<script id="dsq-count-scr" src="///count.js" async></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-114325062-1', 'auto');
  ga('send', 'pageview');
</script>

</body>
</html>

